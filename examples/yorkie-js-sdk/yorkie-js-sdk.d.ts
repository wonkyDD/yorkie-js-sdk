import { BinaryReadOptions } from '@bufbuild/protobuf';
import { default as default_2 } from 'long';
import { FieldList } from '@bufbuild/protobuf';
import { JsonReadOptions } from '@bufbuild/protobuf';
import { JsonValue } from '@bufbuild/protobuf';
import { Message } from '@bufbuild/protobuf';
import { PartialMessage } from '@bufbuild/protobuf';
import { PlainMessage } from '@bufbuild/protobuf';
import { proto3 } from '@bufbuild/protobuf';

/**
 * `ActorID` is used to identify who is making changes to the document.
 * It is a hexadecimal string and should be generated by a unique value.
 *
 * @public
 */
export declare type ActorID = string;

/**
 * `AddOpInfo` represents the information of the add operation.
 */
export declare type AddOpInfo = {
    type: 'add';
    path: string;
    index: number;
};

/**
 * `ArrayOperationInfo` represents the OperationInfo for the JSONArray.
 */
export declare type ArrayOperationInfo = AddOpInfo | RemoveOpInfo | MoveOpInfo;

/**
 * `BaseArray` is a base type of JSONArray.
 */
declare type BaseArray<T> = JSONArray<T> | Array<T>;

/* Excluded from this release type: BaseDocEvent */

declare type BaseObject<T> = JSONObject<T> | Record<string, T>;

/**
 * `bytesToChangeID` creates a ChangeID from the given bytes.
 */
declare function bytesToChangeID(bytes: Uint8Array): ChangeID;

/**
 * `bytesToHex` creates an hex string from the given byte array.
 */
declare function bytesToHex(bytes?: Uint8Array): string;

/**
 * `bytesToObject` creates an JSONObject from the given byte array.
 */
declare function bytesToObject(bytes?: Uint8Array): CRDTObject;

/**
 * `bytesToOperation` creates an Operation from the given bytes.
 */
declare function bytesToOperation(bytes: Uint8Array): Operation;

/**
 * `bytesToSnapshot` creates a Snapshot from the given byte array.
 */
declare function bytesToSnapshot<P extends Indexable>(bytes?: Uint8Array): {
    root: CRDTObject;
    presences: Map<ActorID, P>;
};

/**
 * `Change` represents a unit of modification in the document.
 */
export declare class Change<P extends Indexable> {
    private id;
    private operations;
    private presenceChange?;
    private message?;
    constructor({ id, operations, presenceChange, message, }: {
        id: ChangeID;
        operations?: Array<Operation>;
        presenceChange?: PresenceChange<P>;
        message?: string;
    });
    /**
     * `create` creates a new instance of Change.
     */
    static create<P extends Indexable>({ id, operations, presenceChange, message, }: {
        id: ChangeID;
        operations?: Array<Operation>;
        presenceChange?: PresenceChange<P>;
        message?: string;
    }): Change<P>;
    /**
     * `getID` returns the ID of this change.
     */
    getID(): ChangeID;
    /**
     * `getMessage` returns the message of this change.
     */
    getMessage(): string | undefined;
    /**
     * `hasOperations` returns whether this change has operations or not.
     */
    hasOperations(): boolean;
    /**
     * `getOperations` returns the operations of this change.
     */
    getOperations(): Array<Operation>;
    /**
     * `setActor` sets the given actor.
     */
    setActor(actorID: ActorID): void;
    /**
     * `hasPresenceChange` returns whether this change has presence change or not.
     */
    hasPresenceChange(): boolean;
    /**
     * `getPresenceChange` returns the presence change of this change.
     */
    getPresenceChange(): PresenceChange<P> | undefined;
    /**
     * `execute` executes the operations of this change to the given root.
     */
    execute(root: CRDTRoot, presences: Map<ActorID, P>, source: OpSource): {
        opInfos: Array<OperationInfo>;
        reverseOps: Array<HistoryOperation<P>>;
    };
    /**
     * `toTestString` returns a string containing the meta data of this change.
     */
    toTestString(): string;
    /**
     * `toStruct` returns the structure of this change.
     */
    toStruct(): ChangeStruct<P>;
    /**
     * `fromStruct` creates a instance of Change from the struct.
     */
    static fromStruct<P extends Indexable>(struct: ChangeStruct<P>): Change<P>;
}

/**
 * @generated from message yorkie.v1.Change
 */
declare class Change_2 extends Message<Change_2> {
    /**
     * @generated from field: yorkie.v1.ChangeID id = 1;
     */
    id?: ChangeID_2;

    /**
     * @generated from field: string message = 2;
     */
    message: string;

    /**
     * @generated from field: repeated yorkie.v1.Operation operations = 3;
     */
    operations: Operation_2[];

    /**
     * @generated from field: yorkie.v1.PresenceChange presence_change = 4;
     */
    presenceChange?: PresenceChange_2;

    constructor(data?: PartialMessage<Change_2>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Change";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Change_2;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Change_2;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Change_2;

    static equals(a: Change_2 | PlainMessage<Change_2> | undefined, b: Change_2 | PlainMessage<Change_2> | undefined): boolean;
}

/**
 * `ChangeContext` is used to record the context of modification when editing
 * a document. Each time we add an operation, a new time ticket is issued.
 * Finally returns a Change after the modification has been completed.
 */
declare class ChangeContext<P extends Indexable = Indexable> {
    private id;
    private delimiter;
    private message?;
    private root;
    private operations;
    private presenceChange?;
    /**
     * `previousPresence` stores the previous presence to be used for undoing
     * presence changes.
     */
    private previousPresence;
    /**
     * `reversePresenceKeys` stores the keys of the presence to be used for undoing
     * presence changes.
     */
    private reversePresenceKeys;
    constructor(id: ChangeID, root: CRDTRoot, presence: P, message?: string);
    /**
     * `create` creates a new instance of ChangeContext.
     */
    static create<P extends Indexable>(id: ChangeID, root: CRDTRoot, presence: P, message?: string): ChangeContext<P>;
    /**
     * `push` pushes the given operation to this context.
     */
    push(operation: Operation): void;
    /**
     * `registerElement` registers the given element to the root.
     */
    registerElement(element: CRDTElement, parent: CRDTContainer): void;
    /**
     * `registerRemovedElement` register removed element for garbage collection.
     */
    registerRemovedElement(deleted: CRDTElement): void;
    /**
     * `registerGCPair` registers the given pair to hash table.
     */
    registerGCPair(pair: GCPair): void;
    /**
     * `getChange` creates a new instance of Change in this context.
     */
    getChange(): Change<P>;
    /**
     * `hasChange` returns whether this context has change or not.
     */
    hasChange(): boolean;
    /**
     * `setPresenceChange` registers the presence change to this context.
     */
    setPresenceChange(presenceChange: PresenceChange<P>): void;
    /**
     * `setReversePresence` registers the previous presence to undo presence updates.
     */
    setReversePresence(presence: Partial<P>, option?: {
        addToHistory: boolean;
    }): void;
    /**
     * `toReversePresence` returns the reverse presence of this context.
     */
    getReversePresence(): Partial<P> | undefined;
    /**
     * `issueTimeTicket` creates a time ticket to be used to create a new operation.
     */
    issueTimeTicket(): TimeTicket;
    /**
     * `getLastTimeTicket` returns the last time ticket issued in this context.
     */
    getLastTimeTicket(): TimeTicket;
}

/**
 * `ChangeID` is for identifying the Change. This is immutable.
 */
declare class ChangeID {
    private clientSeq;
    private serverSeq?;
    private lamport;
    private actor;
    constructor(clientSeq: number, lamport: default_2, actor: ActorID, serverSeq?: default_2);
    /**
     * `of` creates a new instance of ChangeID.
     */
    static of(clientSeq: number, lamport: default_2, actor: ActorID, serverSeq?: default_2): ChangeID;
    /**
     * `next` creates a next ID of this ID.
     */
    next(): ChangeID;
    /**
     * `syncLamport` syncs lamport timestamp with the given ID.
     *
     * {@link https://en.wikipedia.org/wiki/Lamport_timestamps#Algorithm}
     */
    syncLamport(otherLamport: default_2): ChangeID;
    /**
     * `createTimeTicket` creates a ticket of the given delimiter.
     */
    createTimeTicket(delimiter: number): TimeTicket;
    /**
     * `setActor` sets the given actor.
     */
    setActor(actorID: ActorID): ChangeID;
    /**
     * `getClientSeq` returns the client sequence of this ID.
     */
    getClientSeq(): number;
    /**
     * `getServerSeq` returns the server sequence of this ID.
     */
    getServerSeq(): string;
    /**
     * `getLamport` returns the lamport clock of this ID.
     */
    getLamport(): default_2;
    /**
     * `getLamportAsString` returns the lamport clock of this ID as a string.
     */
    getLamportAsString(): string;
    /**
     * `getActorID` returns the actor of this ID.
     */
    getActorID(): string;
    /**
     * `toTestString` returns a string containing the meta data of this ID.
     */
    toTestString(): string;
}

/**
 * @generated from message yorkie.v1.ChangeID
 */
declare class ChangeID_2 extends Message<ChangeID_2> {
    /**
     * @generated from field: uint32 client_seq = 1;
     */
    clientSeq: number;

    /**
     * @generated from field: int64 server_seq = 2 [jstype = JS_STRING];
     */
    serverSeq: string;

    /**
     * @generated from field: int64 lamport = 3 [jstype = JS_STRING];
     */
    lamport: string;

    /**
     * @generated from field: bytes actor_id = 4;
     */
    actorId: Uint8Array;

    constructor(data?: PartialMessage<ChangeID_2>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.ChangeID";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChangeID_2;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChangeID_2;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChangeID_2;

    static equals(a: ChangeID_2 | PlainMessage<ChangeID_2> | undefined, b: ChangeID_2 | PlainMessage<ChangeID_2> | undefined): boolean;
}

/**
 * `ChangeInfo` represents the modifications made during a document update
 * and the message passed.
 */
export declare interface ChangeInfo<T = OperationInfo> {
    message: string;
    operations: Array<T>;
    actor: ActorID;
    clientSeq: number;
    serverSeq: string;
}

/**
 * `ChangePack` is a unit for delivering changes in a document to the remote.
 *
 */
declare class ChangePack<P extends Indexable> {
    /**
     * `documentKey` is the key of the document.
     */
    private documentKey;
    /**
     * `Checkpoint` is used to determine the client received changes.
     */
    private checkpoint;
    /**
     * `isRemoved` is a flag that indicates whether the document is removed.
     */
    private isRemoved;
    private changes;
    /**
     * `snapshot` is a byte array that encodes the document.
     */
    private snapshot?;
    /**
     * `minSyncedTicket` is the minimum logical time taken by clients who attach
     * to the document. It is used to collect garbage on the replica on the
     * client.
     */
    private minSyncedTicket?;
    constructor(key: string, checkpoint: Checkpoint, isRemoved: boolean, changes: Array<Change<P>>, snapshot?: Uint8Array, minSyncedTicket?: TimeTicket);
    /**
     * `create` creates a new instance of ChangePack.
     */
    static create<P extends Indexable>(key: string, checkpoint: Checkpoint, isRemoved: boolean, changes: Array<Change<P>>, snapshot?: Uint8Array, minSyncedTicket?: TimeTicket): ChangePack<P>;
    /**
     * `getKey` returns the document key of this pack.
     */
    getDocumentKey(): string;
    /**
     * `getCheckpoint` returns the checkpoint of this pack.
     */
    getCheckpoint(): Checkpoint;
    /**
     * `getIsRemoved` returns the whether this document is removed.
     */
    getIsRemoved(): boolean;
    /**
     * `getChanges` returns the changes of this pack.
     */
    getChanges(): Array<Change<P>>;
    /**
     * `hasChanges` returns the whether this pack has changes or not.
     */
    hasChanges(): boolean;
    /**
     * `getChangeSize` returns the size of changes this pack has.
     */
    getChangeSize(): number;
    /**
     * `hasSnapshot` returns the whether this pack has a snapshot or not.
     */
    hasSnapshot(): boolean;
    /**
     * `getSnapshot` returns the snapshot of this pack.
     */
    getSnapshot(): Uint8Array | undefined;
    /**
     * `getMinSyncedTicket` returns the minimum synced ticket of this pack.
     */
    getMinSyncedTicket(): TimeTicket | undefined;
}

/**
 * ChangePack is a message that contains all changes that occurred in a document.
 * It is used to synchronize changes between clients and servers.
 *
 * @generated from message yorkie.v1.ChangePack
 */
declare class ChangePack_2 extends Message<ChangePack_2> {
    /**
     * @generated from field: string document_key = 1;
     */
    documentKey: string;

    /**
     * @generated from field: yorkie.v1.Checkpoint checkpoint = 2;
     */
    checkpoint?: Checkpoint_2;

    /**
     * @generated from field: bytes snapshot = 3;
     */
    snapshot: Uint8Array;

    /**
     * @generated from field: repeated yorkie.v1.Change changes = 4;
     */
    changes: Change_2[];

    /**
     * @generated from field: yorkie.v1.TimeTicket min_synced_ticket = 5;
     */
    minSyncedTicket?: TimeTicket_2;

    /**
     * @generated from field: bool is_removed = 6;
     */
    isRemoved: boolean;

    constructor(data?: PartialMessage<ChangePack_2>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.ChangePack";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChangePack_2;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChangePack_2;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChangePack_2;

    static equals(a: ChangePack_2 | PlainMessage<ChangePack_2> | undefined, b: ChangePack_2 | PlainMessage<ChangePack_2> | undefined): boolean;
}

/**
 * `ChangeStruct` represents the structure of Change.
 * This is used to serialize and deserialize Change.
 */
declare type ChangeStruct<P extends Indexable> = {
    changeID: string;
    message?: string;
    operations?: Array<string>;
    presenceChange?: {
        type: PresenceChangeType;
        presence?: P;
    };
};

/**
 * `Checkpoint` is used to determine the changes sent and received by the
 * client. This is immutable.
 *
 **/
declare class Checkpoint {
    private serverSeq;
    private clientSeq;
    constructor(serverSeq: default_2, clientSeq: number);
    /**
     * `of` creates a new instance of Checkpoint.
     */
    static of(serverSeq: default_2, clientSeq: number): Checkpoint;
    /**
     * `increaseClientSeq` creates a new instance with increased client sequence.
     */
    increaseClientSeq(inc: number): Checkpoint;
    /**
     * `forward` creates a new instance with the given checkpoint if it is
     * greater than the values of internal properties.
     */
    forward(other: Checkpoint): Checkpoint;
    /**
     * `getServerSeqAsString` returns the server seq of this checkpoint as a
     * string.
     */
    getServerSeqAsString(): string;
    /**
     * `getClientSeq` returns the client seq of this checkpoint.
     */
    getClientSeq(): number;
    /**
     * `getServerSeq` returns the server seq of this checkpoint.
     */
    getServerSeq(): default_2;
    /**
     * `equals` returns whether the given checkpoint is equal to this checkpoint
     * or not.
     */
    equals(other: Checkpoint): boolean;
    /**
     * `toTestString` returns a string containing the meta data of this
     * checkpoint.
     */
    toTestString(): string;
}

/**
 * @generated from message yorkie.v1.Checkpoint
 */
declare class Checkpoint_2 extends Message<Checkpoint_2> {
    /**
     * @generated from field: int64 server_seq = 1 [jstype = JS_STRING];
     */
    serverSeq: string;

    /**
     * @generated from field: uint32 client_seq = 2;
     */
    clientSeq: number;

    constructor(data?: PartialMessage<Checkpoint_2>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Checkpoint";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Checkpoint_2;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Checkpoint_2;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Checkpoint_2;

    static equals(a: Checkpoint_2 | PlainMessage<Checkpoint_2> | undefined, b: Checkpoint_2 | PlainMessage<Checkpoint_2> | undefined): boolean;
}

/**
 * `Client` is a normal client that can communicate with the server.
 * It has documents and sends changes of the documents in local
 * to the server to synchronize with other replicas in remote.
 *
 * @public
 */
export declare class Client {
    private id?;
    private key;
    private status;
    private attachmentMap;
    private apiKey;
    private syncLoopDuration;
    private reconnectStreamDelay;
    private retrySyncLoopDelay;
    private rpcClient;
    /**
     * @param rpcAddr - the address of the RPC server.
     * @param opts - the options of the client.
     */
    constructor(rpcAddr: string, opts?: ClientOptions);
    /**
     * `activate` activates this client. That is, it registers itself to the server
     * and receives a unique ID from the server. The given ID is used to
     * distinguish different clients.
     */
    activate(): Promise<void>;
    /**
     * `deactivate` deactivates this client.
     */
    deactivate(): Promise<void>;
    /**
     * `attach` attaches the given document to this client. It tells the server that
     * this client will synchronize the given document.
     */
    attach<T, P extends Indexable>(doc: Document_2<T, P>, options?: {
        initialPresence?: P;
        syncMode?: SyncMode;
    }): Promise<Document_2<T, P>>;
    /**
     * `detach` detaches the given document from this client. It tells the
     * server that this client will no longer synchronize the given document.
     *
     * To collect garbage things like CRDT tombstones left on the document, all
     * the changes should be applied to other replicas before GC time. For this,
     * if the document is no longer used by this client, it should be detached.
     */
    detach<T, P extends Indexable>(doc: Document_2<T, P>, options?: {
        removeIfNotAttached?: boolean;
    }): Promise<Document_2<T, P>>;
    /**
     * `changeRealtimeSync` changes the synchronization mode of the given document.
     */
    changeSyncMode<T, P extends Indexable>(doc: Document_2<T, P>, syncMode: SyncMode): Promise<Document_2<T, P>>;
    /**
     * `sync` pushes local changes of the attached documents to the server and
     * receives changes of the remote replica from the server then apply them to
     * local documents.
     */
    sync<T, P extends Indexable>(doc?: Document_2<T, P>): Promise<Array<Document_2<T, P>>>;
    /**
     * `remove` removes the given document.
     */
    remove<T, P extends Indexable>(doc: Document_2<T, P>): Promise<void>;
    /**
     * `getID` returns a ActorID of client.
     */
    getID(): string | undefined;
    /**
     * `getKey` returns a key of client.
     */
    getKey(): string;
    /**
     * `isActive` checks if the client is active.
     */
    isActive(): boolean;
    /**
     * `getStatus` returns the status of this client.
     */
    getStatus(): ClientStatus;
    private runSyncLoop;
    private runWatchLoop;
    private handleWatchDocumentsResponse;
    private detachInternal;
    private syncInternal;
}

/**
 * `Client` represents a client value in devtools.
 */
declare type Client_2 = {
    clientID: string;
    presence: Json;
};

/**
 * `ClientOptions` are user-settable options used when defining clients.
 *
 * @public
 */
export declare interface ClientOptions {
    /**
     * `key` is the client key. It is used to identify the client.
     * If not set, a random key is generated.
     */
    key?: string;
    /**
     * `apiKey` is the API key of the project. It is used to identify the project.
     * If not set, API key of the default project is used.
     */
    apiKey?: string;
    /**
     * `token` is the authentication token of this client. It is used to identify
     * the user of the client.
     */
    token?: string;
    /**
     * `syncLoopDuration` is the duration of the sync loop. After each sync loop,
     * the client waits for the duration to next sync. The default value is
     * `50`(ms).
     */
    syncLoopDuration?: number;
    /**
     * `retrySyncLoopDelay` is the delay of the retry sync loop. If the sync loop
     * fails, the client waits for the delay to retry the sync loop. The default
     * value is `1000`(ms).
     */
    retrySyncLoopDelay?: number;
    /**
     * `reconnectStreamDelay` is the delay of the reconnect stream. If the stream
     * is disconnected, the client waits for the delay to reconnect the stream. The
     * default value is `1000`(ms).
     */
    reconnectStreamDelay?: number;
}

/**
 * `ClientStatus` represents the status of the client.
 * @public
 */
export declare enum ClientStatus {
    /**
     * `Deactivated` means that the client is not activated. It is the initial
     * status of the client. If the client is deactivated, all `Document`s of the
     * client are also not used.
     */
    Deactivated = "deactivated",
    /**
     * `Activated` means that the client is activated. If the client is activated,
     * all `Document`s of the client are also ready to be used.
     */
    Activated = "activated"
}

declare type Comparator<K> = (keyA: K, keyB: K) => number;

export declare type CompleteFn = () => void;

/**
 * `ConnectionChangedEvent` is an event that occurs when the stream connection state changes.
 *
 * @public
 */
export declare interface ConnectionChangedEvent extends BaseDocEvent {
    /**
     * enum {@link DocEventType}.ConnectionChanged
     */
    type: DocEventType.ConnectionChanged;
    value: StreamConnectionStatus;
}

/**
 * `ContainerValue` represents the result of `Array.toJSForTest()` and
 * `Object.toJSForTest()`.
 */
declare type ContainerValue = {
    [key: string]: JSONElement_2;
};

/**
 * `converter` is a converter that converts the given model to protobuf format.
 * is also used to convert models to bytes and vice versa.
 */
export declare const converter: {
    fromPresence: typeof fromPresence;
    toChangePack: typeof toChangePack;
    fromChangePack: typeof fromChangePack;
    fromChanges: typeof fromChanges;
    objectToBytes: typeof objectToBytes;
    bytesToObject: typeof bytesToObject;
    bytesToSnapshot: typeof bytesToSnapshot;
    bytesToHex: typeof bytesToHex;
    hexToBytes: typeof hexToBytes;
    toHexString: typeof toHexString;
    toUint8Array: typeof toUint8Array;
    toOperation: typeof toOperation;
    toChangeID: typeof toChangeID;
    PbChangeID: typeof ChangeID_2;
    bytesToChangeID: typeof bytesToChangeID;
    bytesToOperation: typeof bytesToOperation;
};

/**
 * `Counter` is a custom data type that is used to counter.
 */
export declare class Counter {
    private valueType;
    private value;
    private context?;
    private counter?;
    constructor(valueType: CounterType, value: number | default_2);
    /* Excluded from this release type: initialize */
    /**
     * `getID` returns the ID of this text.
     */
    getID(): TimeTicket;
    /* Excluded from this release type: getValue */
    /**
     * `getValueType` returns the value type of this counter.
     */
    getValueType(): CounterType;
    /**
     * `increase` increases numeric data.
     */
    increase(v: number | default_2): Counter;
    /* Excluded from this release type: toJSForTest */
}

/**
 * `CounterOperationInfo` represents the OperationInfo for the yorkie.Counter.
 */
export declare type CounterOperationInfo = IncreaseOpInfo;

declare enum CounterType {
    IntegerCnt = 0,
    LongCnt = 1
}

export declare type CounterValue = number | default_2;

/**
 *
 * `CRDTContainer` represents CRDTArray or CRDtObject.
 */
declare abstract class CRDTContainer extends CRDTElement {
    constructor(createdAt: TimeTicket);
    /**
     * `subPathOf` returns the sub path of the given element.
     */
    abstract subPathOf(createdAt: TimeTicket): string | undefined;
    abstract purge(element: CRDTElement): void;
    abstract delete(createdAt: TimeTicket, executedAt: TimeTicket): CRDTElement;
    abstract getDescendants(callback: (elem: CRDTElement, parent: CRDTContainer) => boolean): void;
    /**
     * `get` returns the element of the given key or index. This method is called
     * by users. So it should return undefined if the element is removed.
     */
    abstract get(keyOrIndex: string | number): CRDTElement | undefined;
    /**
     * `getByID` returns the element of the given creation time. This method is
     * called by internal. So it should return the element even if the element is
     * removed.
     */
    abstract getByID(createdAt: TimeTicket): CRDTElement | undefined;
}

/* Excluded from this release type: CRDTCounter */

/* Excluded from this release type: CRDTElement */

/**
 * `CRDTElementPair` is a structure that represents a pair of element and its
 * parent. It is used to find the parent of a specific element to perform
 * garbage collection and to find the path of a specific element.
 */
declare interface CRDTElementPair {
    element: CRDTElement;
    parent?: CRDTContainer;
}

/**
 * `CRDTObject` represents an object data type, but unlike regular JSON,
 * it has `TimeTicket`s which are created by logical clock.
 *
 */
declare class CRDTObject extends CRDTContainer {
    private memberNodes;
    constructor(createdAt: TimeTicket, memberNodes: ElementRHT);
    /**
     * `create` creates a new instance of CRDTObject.
     */
    static create(createdAt: TimeTicket, value?: {
        [key: string]: CRDTElement;
    }): CRDTObject;
    /**
     * `subPathOf` returns the sub path of the given element.
     */
    subPathOf(createdAt: TimeTicket): string | undefined;
    /**
     * `purge` physically purges the given element.
     */
    purge(value: CRDTElement): void;
    /**
     * `set` sets the given element of the given key.
     */
    set(key: string, value: CRDTElement, executedAt: TimeTicket): CRDTElement | undefined;
    /**
     * `delete` deletes the element of the given key.
     */
    delete(createdAt: TimeTicket, executedAt: TimeTicket): CRDTElement;
    /**
     * `deleteByKey` deletes the element of the given key and execution time.
     */
    deleteByKey(key: string, executedAt: TimeTicket): CRDTElement | undefined;
    /**
     * `get` returns the value of the given key.
     */
    get(key: string): CRDTElement | undefined;
    /**
     * `getByID` returns the element of the given createAt.
     */
    getByID(createdAt: TimeTicket): CRDTElement | undefined;
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key: string): boolean;
    /**
     * `toJSON` returns the JSON encoding of this object.
     */
    toJSON(): string;
    /**
     * `toJS` returns the JavaScript object of this object.
     */
    toJS(): any;
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest(): Devtools.JSONElement;
    /**
     * `getKeys` returns array of keys in this object.
     */
    getKeys(): Array<string>;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this object.
     */
    toSortedJSON(): string;
    /**
     * `getRHT` RHTNodes returns the RHTPQMap nodes.
     */
    getRHT(): ElementRHT;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTObject;
    /**
     * `getDescendants` returns the descendants of this object by traversing.
     */
    getDescendants(callback: (elem: CRDTElement, parent: CRDTContainer) => boolean): void;
    /* Excluded from this release type: [Symbol.iterator] */
}

/**
 * `CRDTRoot` is a structure that represents the root. It has a hash table of
 * all elements to find a specific element when applying remote changes
 * received from server.
 *
 * Every element has a unique `TimeTicket` at creation, which allows us to find
 * a particular element.
 */
declare class CRDTRoot {
    /**
     * `rootObject` is the root object of the document.
     */
    private rootObject;
    /**
     * `elementPairMapByCreatedAt` is a hash table that maps the creation time of
     * an element to the element itself and its parent.
     */
    private elementPairMapByCreatedAt;
    /**
     * `gcElementSetByCreatedAt` is a hash set that contains the creation
     * time of the removed element. It is used to find the removed element when
     * executing garbage collection.
     */
    private gcElementSetByCreatedAt;
    /**
     * `gcPairMap` is a hash table that maps the IDString of GCChild to the
     * element itself and its parent.
     */
    private gcPairMap;
    constructor(rootObject: CRDTObject);
    /**
     * `create` creates a new instance of Root.
     */
    static create(): CRDTRoot;
    /**
     * `findByCreatedAt` returns the element of given creation time.
     */
    findByCreatedAt(createdAt: TimeTicket): CRDTElement | undefined;
    /**
     * `findElementPairByCreatedAt` returns the element and parent pair
     * of given creation time.
     */
    findElementPairByCreatedAt(createdAt: TimeTicket): CRDTElementPair | undefined;
    /**
     * `createSubPaths` creates an array of the sub paths for the given element.
     */
    createSubPaths(createdAt: TimeTicket): Array<string>;
    /**
     * `createPath` creates path of the given element.
     */
    createPath(createdAt: TimeTicket): string;
    /**
     * `registerElement` registers the given element and its descendants to hash table.
     */
    registerElement(element: CRDTElement, parent?: CRDTContainer): void;
    /**
     * `deregisterElement` deregister the given element and its descendants from hash table.
     */
    deregisterElement(element: CRDTElement): number;
    /**
     * `registerRemovedElement` registers the given element to the hash set.
     */
    registerRemovedElement(element: CRDTElement): void;
    /**
     * `registerGCPair` registers the given pair to hash table.
     */
    registerGCPair(pair: GCPair): void;
    /**
     * `getElementMapSize` returns the size of element map.
     */
    getElementMapSize(): number;
    /**
     * `getGarbageElementSetSize()` returns the size of removed element set.
     */
    getGarbageElementSetSize(): number;
    /**
     * `getObject` returns root object.
     */
    getObject(): CRDTObject;
    /**
     * `getGarbageLen` returns length of nodes which can be garbage collected.
     */
    getGarbageLen(): number;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTRoot;
    /**
     * `garbageCollect` purges elements that were removed before the given time.
     */
    garbageCollect(ticket: TimeTicket): number;
    /**
     * `toJSON` returns the JSON encoding of this root object.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this root object.
     */
    toSortedJSON(): string;
}

/**
 *  `CRDTText` is a custom CRDT data type to represent the contents of text editors.
 *
 */
declare class CRDTText<A extends Indexable = Indexable> extends CRDTElement {
    private rgaTreeSplit;
    constructor(rgaTreeSplit: RGATreeSplit<CRDTTextValue>, createdAt: TimeTicket);
    /**
     * `create` a instance of Text.
     */
    static create<A extends Indexable>(rgaTreeSplit: RGATreeSplit<CRDTTextValue>, createdAt: TimeTicket): CRDTText<A>;
    /* Excluded from this release type: edit */
    /* Excluded from this release type: setStyle */
    /**
     * `indexRangeToPosRange` returns the position range of the given index range.
     */
    indexRangeToPosRange(fromIdx: number, toIdx: number): RGATreeSplitPosRange;
    /**
     * `length` returns size of RGATreeList.
     */
    get length(): number;
    /**
     * `checkWeight` returns false when there is an incorrect weight node.
     * for debugging purpose.
     */
    checkWeight(): boolean;
    /**
     * `toJSON` returns the JSON encoding of this text.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this text.
     */
    toSortedJSON(): string;
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest(): Devtools.JSONElement;
    /**
     * `toString` returns the string representation of this text.
     */
    toString(): string;
    /**
     * `values` returns the content-attributes pair array of this text.
     */
    values(): Array<TextValueType<A>>;
    /* Excluded from this release type: getRGATreeSplit */
    /**
     * `toTestString` returns a String containing the meta data of this value
     * for debugging purpose.
     */
    toTestString(): string;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTText<A>;
    /**
     * `findIndexesFromRange` returns pair of integer offsets of the given range.
     */
    findIndexesFromRange(range: RGATreeSplitPosRange): [number, number];
    /**
     * `getGCPairs` returns the pairs of GC.
     */
    getGCPairs(): Array<GCPair>;
}

/**
 * `CRDTTextValue` is a value of Text
 * which has a attributes that expresses the text style.
 * Attributes are represented by RHT.
 *
 */
declare class CRDTTextValue {
    private attributes;
    private content;
    constructor(content: string);
    /**
     * `create` creates a instance of CRDTTextValue.
     */
    static create(content: string): CRDTTextValue;
    /**
     * `length` returns the length of value.
     */
    get length(): number;
    /**
     * `substring` returns a sub-string value of the given range.
     */
    substring(indexStart: number, indexEnd: number): CRDTTextValue;
    /**
     * `setAttr` sets attribute of the given key, updated time and value.
     */
    setAttr(key: string, content: string, updatedAt: TimeTicket): [RHTNode | undefined, RHTNode | undefined];
    /**
     * `getAttr` returns the attributes of this value.
     */
    getAttrs(): RHT;
    /**
     * `toString` returns the string representation of this value.
     */
    toString(): string;
    /**
     * `toJSON` returns the JSON encoding of this value.
     */
    toJSON(): string;
    /**
     * `getAttributes` returns the attributes of this value.
     */
    getAttributes(): Record<string, string>;
    /**
     * `getContent` returns the internal content.
     */
    getContent(): string;
    /**
     * `purge` purges the given child node.
     */
    purge(node: GCChild): void;
    /**
     * `getGCPairs` returns the pairs of GC.
     */
    getGCPairs(): Array<GCPair>;
}

/**
 * `CRDTTree` is a CRDT implementation of a tree.
 */
declare class CRDTTree extends CRDTElement implements GCParent {
    private indexTree;
    private nodeMapByID;
    constructor(root: CRDTTreeNode, createdAt: TimeTicket);
    /**
     * `create` creates a new instance of `CRDTTree`.
     */
    static create(root: CRDTTreeNode, ticket: TimeTicket): CRDTTree;
    /**
     * `findFloorNode` finds node of given id.
     */
    findFloorNode(id: CRDTTreeNodeID): CRDTTreeNode | undefined;
    /**
     * `registerNode` registers the given node to the tree.
     */
    registerNode(node: CRDTTreeNode): void;
    /**
     * `findNodesAndSplitText` finds `TreePos` of the given `CRDTTreeNodeID` and
     * splits nodes if the position is in the middle of a text node.
     *
     * The ids of the given `pos` are the ids of the node in the CRDT perspective.
     * This is different from `TreePos` which is a position of the tree in the
     * physical perspective.
     *
     * If `editedAt` is given, then it is used to find the appropriate left node
     * for concurrent insertion.
     */
    findNodesAndSplitText(pos: CRDTTreePos, editedAt?: TimeTicket): TreeNodePair;
    /**
     * `style` applies the given attributes of the given range.
     */
    style(range: [CRDTTreePos, CRDTTreePos], attributes: {
        [key: string]: string;
    } | undefined, editedAt: TimeTicket, maxCreatedAtMapByActor?: Map<string, TimeTicket>): [Map<string, TimeTicket>, Array<GCPair>, Array<TreeChange>];
    /**
     * `removeStyle` removes the given attributes of the given range.
     */
    removeStyle(range: [CRDTTreePos, CRDTTreePos], attributesToRemove: Array<string>, editedAt: TimeTicket, maxCreatedAtMapByActor?: Map<string, TimeTicket>): [Map<string, TimeTicket>, Array<GCPair>, Array<TreeChange>];
    /**
     * `edit` edits the tree with the given range and content.
     * If the content is undefined, the range will be removed.
     */
    edit(range: [CRDTTreePos, CRDTTreePos], contents: Array<CRDTTreeNode> | undefined, splitLevel: number, editedAt: TimeTicket, issueTimeTicket: (() => TimeTicket) | undefined, maxCreatedAtMapByActor?: Map<string, TimeTicket>): [Array<TreeChange>, Array<GCPair>, Map<string, TimeTicket>];
    /**
     * `editT` edits the given range with the given value.
     * This method uses indexes instead of a pair of TreePos for testing.
     */
    editT(range: [number, number], contents: Array<CRDTTreeNode> | undefined, splitLevel: number, editedAt: TimeTicket, issueTimeTicket: () => TimeTicket): void;
    /**
     * `move` move the given source range to the given target range.
     */
    move(target: [number, number], source: [number, number], ticket: TimeTicket): void;
    /**
     * `purge` physically purges the given node.
     */
    purge(node: CRDTTreeNode): void;
    /**
     * `getGCPairs` returns the pairs of GC.
     */
    getGCPairs(): Array<GCPair>;
    /**
     * `findPos` finds the position of the given index in the tree.
     */
    findPos(index: number, preferText?: boolean): CRDTTreePos;
    /**
     * `pathToPosRange` converts the given path of the node to the range of the position.
     */
    pathToPosRange(path: Array<number>): [CRDTTreePos, CRDTTreePos];
    /**
     * `pathToPos` finds the position of the given index in the tree by path.
     */
    pathToPos(path: Array<number>): CRDTTreePos;
    /**
     * `getRoot` returns the root node of the tree.
     */
    getRoot(): CRDTTreeNode;
    /**
     * `getSize` returns the size of the tree.
     */
    getSize(): number;
    /**
     * `getNodeSize` returns the size of the LLRBTree.
     */
    getNodeSize(): number;
    /**
     * `getIndexTree` returns the index tree.
     */
    getIndexTree(): IndexTree<CRDTTreeNode>;
    /**
     * toXML returns the XML encoding of this tree.
     */
    toXML(): string;
    /**
     * `toJSON` returns the JSON encoding of this tree.
     */
    toJSON(): string;
    /* Excluded from this release type: toJSForTest */
    /* Excluded from this release type: toJSInfoForTest */
    /**
     * `getRootTreeNode` returns the converted value of this tree to TreeNode.
     */
    getRootTreeNode(): TreeNode;
    /**
     * `toTestTreeNode` returns the JSON of this tree for debugging.
     */
    toTestTreeNode(): TreeNodeForTest;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this tree.
     */
    toSortedJSON(): string;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTTree;
    /**
     * `toPath` converts the given CRDTTreeNodeID to the path of the tree.
     */
    toPath(parentNode: CRDTTreeNode, leftNode: CRDTTreeNode): Array<number>;
    /**
     * `toIndex` converts the given CRDTTreeNodeID to the index of the tree.
     */
    toIndex(parentNode: CRDTTreeNode, leftNode: CRDTTreeNode): number;
    /**
     * `indexToPath` converts the given tree index to path.
     */
    indexToPath(index: number): Array<number>;
    /**
     * `pathToIndex` converts the given path to index.
     */
    pathToIndex(path: Array<number>): number;
    /**
     * `indexRangeToPosRange` returns the position range from the given index range.
     */
    indexRangeToPosRange(range: [number, number]): TreePosRange;
    /**
     * `indexRangeToPosStructRange` converts the integer index range into the Tree position range structure.
     */
    indexRangeToPosStructRange(range: [number, number]): TreePosStructRange;
    /**
     * `posRangeToPathRange` converts the given position range to the path range.
     */
    posRangeToPathRange(range: TreePosRange): [Array<number>, Array<number>];
    /**
     * `posRangeToIndexRange` converts the given position range to the path range.
     */
    posRangeToIndexRange(range: TreePosRange): [number, number];
    /**
     * `traverseInPosRange` traverses the tree in the given position range.
     */
    private traverseInPosRange;
    /**
     * `toTreePos` converts the given nodes to the position of the IndexTree.
     */
    private toTreePos;
    /**
     * `makeDeletionChanges` converts nodes to be deleted to deletion changes.
     */
    private makeDeletionChanges;
    /**
     * `findRightToken` returns the token to the right of the given token in the tree.
     */
    private findRightToken;
    /**
     * `findLeftToken` returns the token to the left of the given token in the tree.
     */
    private findLeftToken;
}

/**
 * `CRDTTreeNode` is a node of CRDTTree. It includes the logical clock and
 * links to other nodes to resolve conflicts.
 */
declare class CRDTTreeNode extends IndexTreeNode<CRDTTreeNode> implements GCParent, GCChild {
    id: CRDTTreeNodeID;
    removedAt?: TimeTicket;
    attrs?: RHT;
    /**
     * `insPrevID` is the previous node id of this node after the node is split.
     */
    insPrevID?: CRDTTreeNodeID;
    /**
     * `insNextID` is the previous node id of this node after the node is split.
     */
    insNextID?: CRDTTreeNodeID;
    _value: string;
    constructor(id: CRDTTreeNodeID, type: string, opts?: string | Array<CRDTTreeNode>, attributes?: RHT, removedAt?: TimeTicket);
    /**
     * `toIDString` returns the IDString of this node.
     */
    toIDString(): string;
    /**
     * `getRemovedAt` returns the time when this node was removed.
     */
    getRemovedAt(): TimeTicket | undefined;
    /**
     * `create` creates a new instance of CRDTTreeNode.
     */
    static create(id: CRDTTreeNodeID, type: string, opts?: string | Array<CRDTTreeNode>, attributes?: RHT): CRDTTreeNode;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTTreeNode;
    /**
     * `value` returns the value of the node.
     */
    get value(): string;
    /**
     * `value` sets the value of the node.
     */
    set value(v: string);
    /**
     * `isRemoved` returns whether the node is removed or not.
     */
    get isRemoved(): boolean;
    /**
     * `remove` marks the node as removed.
     */
    remove(removedAt: TimeTicket): void;
    /**
     * `cloneText` clones this text node with the given offset.
     */
    cloneText(offset: number): CRDTTreeNode;
    /**
     * `cloneElement` clones this element node with the given issueTimeTicket function.
     */
    cloneElement(issueTimeTicket: () => TimeTicket): CRDTTreeNode;
    /**
     * `split` splits the given offset of this node.
     */
    split(tree: CRDTTree, offset: number, issueTimeTicket?: () => TimeTicket): CRDTTreeNode | undefined;
    /**
     * `getCreatedAt` returns the creation time of this element.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getOffset` returns the offset of a pos.
     */
    getOffset(): number;
    /**
     * `canDelete` checks if node is able to delete.
     */
    canDelete(editedAt: TimeTicket, maxCreatedAt: TimeTicket): boolean;
    /**
     * `canStyle` checks if node is able to style.
     */
    canStyle(editedAt: TimeTicket, maxCreatedAt: TimeTicket): boolean;
    /**
     * `setAttrs` sets the attributes of the node.
     */
    setAttrs(attrs: {
        [key: string]: string;
    }, editedAt: TimeTicket): Array<[RHTNode | undefined, RHTNode | undefined]>;
    /**
     * `purge` purges the given child node.
     */
    purge(node: RHTNode): void;
    /**
     * `getGCPairs` returns the pairs of GC.
     */
    getGCPairs(): Array<GCPair>;
}

/**
 * `CRDTTreeNodeID` represent an ID of a node in the tree. It is used to
 * identify a node in the tree. It is composed of the creation time of the node
 * and the offset from the beginning of the node if the node is split.
 *
 * Some of replicas may have nodes that are not split yet. In this case, we can
 * use `map.floorEntry()` to find the adjacent node.
 */
declare class CRDTTreeNodeID {
    /**
     * `createdAt` is the creation time of the node.
     */
    private createdAt;
    /**
     * `offset` is the distance from the beginning of the node if the node is
     * split.
     */
    private offset;
    constructor(createdAt: TimeTicket, offset: number);
    /**
     * `of` creates a new instance of CRDTTreeNodeID.
     */
    static of(createdAt: TimeTicket, offset: number): CRDTTreeNodeID;
    /**
     * `fromStruct` creates a new instance of CRDTTreeNodeID from the given struct.
     */
    static fromStruct(struct: CRDTTreeNodeIDStruct): CRDTTreeNodeID;
    /**
     * `createComparator` creates a comparator for CRDTTreeNodeID.
     */
    static createComparator(): Comparator<CRDTTreeNodeID>;
    /**
     * `getCreatedAt` returns the creation time of the node.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `equals` returns whether given ID equals to this ID or not.
     */
    equals(other: CRDTTreeNodeID): boolean;
    /**
     * `getOffset` returns returns the offset of the node.
     */
    getOffset(): number;
    /**
     * `setOffset` sets the offset of the node.
     */
    setOffset(offset: number): void;
    /**
     * `toStruct` returns the structure of this position.
     */
    toStruct(): CRDTTreeNodeIDStruct;
    /**
     * `toIDString` returns a string that can be used as an ID for this position.
     */
    toIDString(): string;
    /**
     * `toTestString` returns a string containing the meta data of the ticket
     * for debugging purpose.
     */
    toTestString(): string;
}

/**
 * `CRDTTreeNodeIDStruct` represents the structure of CRDTTreeNodeID.
 * It is used to serialize and deserialize the CRDTTreeNodeID.
 */
export declare type CRDTTreeNodeIDStruct = {
    createdAt: TimeTicketStruct;
    offset: number;
};

/**
 * `CRDTTreePos` represent a position in the tree. It is used to identify a
 * position in the tree. It is composed of the parent ID and the left sibling
 * ID. If there's no left sibling in parent's children, then left sibling is
 * parent.
 */
declare class CRDTTreePos {
    private parentID;
    private leftSiblingID;
    constructor(parentID: CRDTTreeNodeID, leftSiblingID: CRDTTreeNodeID);
    /**
     * `of` creates a new instance of CRDTTreePos.
     */
    static of(parentID: CRDTTreeNodeID, leftSiblingID: CRDTTreeNodeID): CRDTTreePos;
    /**
     * `fromTreePos` creates a new instance of CRDTTreePos from the given TreePos.
     */
    static fromTreePos(pos: TreePos<CRDTTreeNode>): CRDTTreePos;
    /**
     * `getParentID` returns the parent ID.
     */
    getParentID(): CRDTTreeNodeID;
    /**
     * `fromStruct` creates a new instance of CRDTTreeNodeID from the given struct.
     */
    static fromStruct(struct: CRDTTreePosStruct): CRDTTreePos;
    /**
     * `toStruct` returns the structure of this position.
     */
    toStruct(): CRDTTreePosStruct;
    /**
     * `toTreeNodePair` converts the pos to parent and left sibling nodes.
     * If the position points to the middle of a node, then the left sibling node
     * is the node that contains the position. Otherwise, the left sibling node is
     * the node that is located at the left of the position.
     */
    toTreeNodePair(tree: CRDTTree): TreeNodePair;
    /**
     * `getLeftSiblingID` returns the left sibling ID.
     */
    getLeftSiblingID(): CRDTTreeNodeID;
    /**
     * `equals` returns whether the given pos equals to this or not.
     */
    equals(other: CRDTTreePos): boolean;
}

/**
 * `CRDTTreePosStruct` represents the structure of CRDTTreePos.
 */
declare type CRDTTreePosStruct = {
    parentID: CRDTTreeNodeIDStruct;
    leftSiblingID: CRDTTreeNodeIDStruct;
};

/**
 * `DecreasedDepthOf` represents the type of the decreased depth of the given depth.
 */
declare type DecreasedDepthOf<Depth extends number = 0> = Depth extends 10 ? 9 : Depth extends 9 ? 8 : Depth extends 8 ? 7 : Depth extends 7 ? 6 : Depth extends 6 ? 5 : Depth extends 5 ? 4 : Depth extends 4 ? 3 : Depth extends 3 ? 2 : Depth extends 2 ? 1 : Depth extends 1 ? 0 : -1;

/**
 * The top-level yorkie namespace with additional properties.
 *
 * In production, this will be called exactly once and the result
 * assigned to the `yorkie` global.
 *
 * e.g) `new yorkie.Client(...);`
 *
 * @public
 */
declare const _default: {
    Client: typeof Client;
    Document: typeof Document_2;
    Primitive: typeof Primitive;
    Text: typeof Text_2;
    Counter: typeof Counter;
    Tree: typeof Tree;
    IntType: CounterType;
    LongType: CounterType;
};
export default _default;

/**
 * `DefaultTextType` is the default type of the text node.
 * It is used when the type of the text node is not specified.
 */
declare const DefaultTextType = "text";

declare namespace Devtools {
    export {
        Json,
        Client_2 as Client,
        JSONElement_2 as JSONElement,
        ContainerValue,
        TreeNodeInfo
    }
}
export { Devtools }

/**
 * `DocEvent` is an event that occurs in `Document`. It can be delivered
 * using `Document.subscribe()`.
 *
 * @public
 */
export declare type DocEvent<P extends Indexable = Indexable, T = OperationInfo> = StatusChangedEvent | ConnectionChangedEvent | SyncStatusChangedEvent | SnapshotEvent | LocalChangeEvent<T, P> | RemoteChangeEvent<T, P> | InitializedEvent<P> | WatchedEvent<P> | UnwatchedEvent<P> | PresenceChangedEvent<P>;

/**
 * @generated from message yorkie.v1.DocEvent
 */
declare class DocEvent_2 extends Message<DocEvent_2> {
    /**
     * @generated from field: yorkie.v1.DocEventType type = 1;
     */
    type: DocEventType_2;

    /**
     * @generated from field: string publisher = 2;
     */
    publisher: string;

    /**
     * @generated from field: yorkie.v1.DocEventBody body = 3;
     */
    body?: DocEventBody;

    constructor(data?: PartialMessage<DocEvent_2>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.DocEvent";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocEvent_2;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocEvent_2;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocEvent_2;

    static equals(a: DocEvent_2 | PlainMessage<DocEvent_2> | undefined, b: DocEvent_2 | PlainMessage<DocEvent_2> | undefined): boolean;
}

/**
 * @generated from message yorkie.v1.DocEventBody
 */
declare class DocEventBody extends Message<DocEventBody> {
    /**
     * @generated from field: string topic = 1;
     */
    topic: string;

    /**
     * @generated from field: bytes payload = 2;
     */
    payload: Uint8Array;

    constructor(data?: PartialMessage<DocEventBody>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.DocEventBody";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocEventBody;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocEventBody;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocEventBody;

    static equals(a: DocEventBody | PlainMessage<DocEventBody> | undefined, b: DocEventBody | PlainMessage<DocEventBody> | undefined): boolean;
}

declare type DocEventCallbackMap<P extends Indexable> = {
    default: NextFn<SnapshotEvent | LocalChangeEvent<OperationInfo, P> | RemoteChangeEvent<OperationInfo, P>>;
    presence: NextFn<InitializedEvent<P> | WatchedEvent<P> | UnwatchedEvent<P> | PresenceChangedEvent<P>>;
    'my-presence': NextFn<InitializedEvent<P> | PresenceChangedEvent<P>>;
    others: NextFn<WatchedEvent<P> | UnwatchedEvent<P> | PresenceChangedEvent<P>>;
    connection: NextFn<ConnectionChangedEvent>;
    status: NextFn<StatusChangedEvent>;
    sync: NextFn<SyncStatusChangedEvent>;
    all: NextFn<TransactionEvent<P>>;
};

/**
 * `DocEventType` represents the type of the event that occurs in `Document`.
 * @public
 */
export declare enum DocEventType {
    /**
     * status changed event type
     */
    StatusChanged = "status-changed",
    /**
     * `ConnectionChanged` means that the watch stream connection status has changed.
     */
    ConnectionChanged = "connection-changed",
    /**
     * `SyncStatusChanged` means that the document sync status has changed.
     */
    SyncStatusChanged = "sync-status-changed",
    /**
     * snapshot event type
     */
    Snapshot = "snapshot",
    /**
     * local document change event type
     */
    LocalChange = "local-change",
    /**
     * remote document change event type
     */
    RemoteChange = "remote-change",
    /**
     * `Initialized` means that online clients have been loaded from the server.
     */
    Initialized = "initialized",
    /**
     * `Watched` means that the client has established a connection with the server,
     * enabling real-time synchronization.
     */
    Watched = "watched",
    /**
     * `Unwatched` means that the connection has been disconnected.
     */
    Unwatched = "unwatched",
    /**
     * `PresenceChanged` means that the presences of the client has updated.
     */
    PresenceChanged = "presence-changed"
}

/**
 * @generated from enum yorkie.v1.DocEventType
 */
declare enum DocEventType_2 {
    /**
     * @generated from enum value: DOC_EVENT_TYPE_DOCUMENT_CHANGED = 0;
     */
    DOCUMENT_CHANGED = 0,

    /**
     * @generated from enum value: DOC_EVENT_TYPE_DOCUMENT_WATCHED = 1;
     */
    DOCUMENT_WATCHED = 1,

    /**
     * @generated from enum value: DOC_EVENT_TYPE_DOCUMENT_UNWATCHED = 2;
     */
    DOCUMENT_UNWATCHED = 2,

    /**
     * @generated from enum value: DOC_EVENT_TYPE_DOCUMENT_BROADCAST = 3;
     */
    DOCUMENT_BROADCAST = 3,
}

/**
 * `Document` is a CRDT-based data type. We can represent the model
 * of the application and edit it even while offline.
 *
 * @public
 */
declare class Document_2<T, P extends Indexable = Indexable> {
    private key;
    private status;
    private opts;
    private changeID;
    private checkpoint;
    private localChanges;
    private root;
    private clone?;
    private eventStream;
    private eventStreamObserver;
    /**
     * `onlineClients` is a set of client IDs that are currently online.
     */
    private onlineClients;
    /**
     * `presences` is a map of client IDs to their presence information.
     */
    private presences;
    /**
     * `history` is exposed to the user to manage undo/redo operations.
     */
    history: {
        canUndo: () => boolean;
        canRedo: () => boolean;
        undo: () => void;
        redo: () => void;
    };
    /**
     * `internalHistory` is used to manage undo/redo operations internally.
     */
    internalHistory: History_2<P>;
    /**
     * `isUpdating` is whether the document is updating by updater or not. It is
     * used to prevent the updater from calling undo/redo.
     */
    private isUpdating;
    constructor(key: string, opts?: DocumentOptions);
    /**
     * `update` executes the given updater to update this document.
     */
    update(updater: (root: JSONObject<T>, presence: Presence<P>) => void, message?: string): void;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the document is changed.
     */
    subscribe(next: DocEventCallbackMap<P>['default'], error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the clients watching the document
     * establishe or update its presence.
     */
    subscribe(type: 'presence', next: DocEventCallbackMap<P>['presence'], error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the current client establishes or updates its presence.
     */
    subscribe(type: 'my-presence', next: DocEventCallbackMap<P>['my-presence'], error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the client establishes or terminates a connection,
     * or updates its presence.
     */
    subscribe(type: 'others', next: DocEventCallbackMap<P>['others'], error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the stream connection status changes.
     */
    subscribe(type: 'connection', next: DocEventCallbackMap<P>['connection'], error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the document status changes.
     */
    subscribe(type: 'status', next: DocEventCallbackMap<P>['status'], error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the document is synced with the server.
     */
    subscribe(type: 'sync', next: DocEventCallbackMap<P>['sync'], error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the targetPath or any of its nested values change.
     */
    subscribe<TPath extends PathOf<T>, TOperationInfo extends OperationInfoOf<T, TPath>>(targetPath: TPath, next: NextFn<LocalChangeEvent<TOperationInfo, P> | RemoteChangeEvent<TOperationInfo, P>>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     */
    subscribe(type: 'all', next: DocEventCallbackMap<P>['all'], error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `publish` triggers an event in this document, which can be received by
     * callback functions from document.subscribe().
     */
    publish(event: TransactionEvent<P>): void;
    private isSameElementOrChildOf;
    /* Excluded from this release type: applyChangePack */
    /* Excluded from this release type: getCheckpoint */
    /* Excluded from this release type: getChangeID */
    /**
     * `hasLocalChanges` returns whether this document has local changes or not.
     */
    hasLocalChanges(): boolean;
    /* Excluded from this release type: ensureClone */
    /* Excluded from this release type: createChangePack */
    /* Excluded from this release type: setActor */
    /**
     * `isEnableDevtools` returns whether devtools is enabled or not.
     */
    isEnableDevtools(): boolean;
    /**
     * `getKey` returns the key of this document.
     */
    getKey(): string;
    /**
     * `getStatus` returns the status of this document.
     */
    getStatus(): DocumentStatus;
    /* Excluded from this release type: getCloneRoot */
    /**
     * `getRoot` returns a new proxy of cloned root.
     */
    getRoot(): JSONObject<T>;
    /* Excluded from this release type: garbageCollect */
    /* Excluded from this release type: getRootObject */
    /* Excluded from this release type: getGarbageLen */
    /**
     * `getGarbageLenFromClone` returns the length of elements should be purged from clone.
     */
    getGarbageLenFromClone(): number;
    /**
     * `toJSON` returns the JSON encoding of this document.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this document.
     */
    toSortedJSON(): string;
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest(): Devtools.JSONElement;
    /**
     * `applySnapshot` applies the given snapshot into this document.
     */
    applySnapshot(serverSeq: default_2, snapshot?: Uint8Array): void;
    /**
     * `applyChanges` applies the given changes into this document.
     */
    applyChanges(changes: Array<Change<P>>, source: OpSource): void;
    /**
     * `applyChange` applies the given change into this document.
     */
    applyChange(change: Change<P>, source: OpSource): void;
    /**
     * `applyWatchStream` applies the given watch stream response into this document.
     */
    applyWatchStream(resp: WatchDocumentResponse): void;
    /**
     * `applyStatus` applies the document status into this document.
     */
    applyStatus(status: DocumentStatus): void;
    /**
     * `applyDocEvent` applies the docEvent into this document.
     */
    applyDocEvent(event: DocEvent<P>): void;
    /**
     * `applyTransactionEvent` applies the given TransactionEvent into this document.
     */
    applyTransactionEvent(event: TransactionEvent<P>): void;
    /**
     * `getValueByPath` returns the JSONElement corresponding to the given path.
     */
    getValueByPath(path: string): JSONElement | undefined;
    /* Excluded from this release type: setOnlineClients */
    /* Excluded from this release type: resetOnlineClients */
    /* Excluded from this release type: addOnlineClient */
    /* Excluded from this release type: removeOnlineClient */
    /* Excluded from this release type: hasPresence */
    /**
     * `getMyPresence` returns the presence of the current client.
     */
    getMyPresence(): P;
    /**
     * `getPresence` returns the presence of the given clientID.
     */
    getPresence(clientID: ActorID): P | undefined;
    /* Excluded from this release type: getPresenceForTest */
    /**
     * `getPresences` returns the presences of online clients.
     */
    getPresences(): Array<{
        clientID: ActorID;
        presence: P;
    }>;
    /* Excluded from this release type: getSelfForTest */
    /* Excluded from this release type: getOthersForTest */
    /**
     * `canUndo` returns whether there are any operations to undo.
     */
    private canUndo;
    /**
     * `canRedo` returns whether there are any operations to redo.
     */
    private canRedo;
    /**
     * `undo` undoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     */
    private undo;
    /**
     * `redo` redoes the last operation executed by the current client.
     * It does not impact operations made by other clients.
     */
    private redo;
    /**
     * `getUndoStackForTest` returns the undo stack for test.
     */
    getUndoStackForTest(): Array<Array<HistoryOperation<P>>>;
    /**
     * `getRedoStackForTest` returns the redo stack for test.
     */
    getRedoStackForTest(): Array<Array<HistoryOperation<P>>>;
}
export { Document_2 as Document }

/**
 * `DocumentOptions` are the options to create a new document.
 *
 * @public
 */
declare interface DocumentOptions {
    /**
     * `disableGC` disables garbage collection if true.
     */
    disableGC?: boolean;
    /**
     * `enableDevtools` enables devtools if true.
     */
    enableDevtools?: boolean;
}

/**
 * `DocumentStatus` represents the status of the document.
 * @public
 */
export declare enum DocumentStatus {
    /**
     * Detached means that the document is not attached to the client.
     * The actor of the ticket is created without being assigned.
     */
    Detached = "detached",
    /**
     * Attached means that this document is attached to the client.
     * The actor of the ticket is created with being assigned by the client.
     */
    Attached = "attached",
    /**
     * Removed means that this document is removed. If the document is removed,
     * it cannot be edited.
     */
    Removed = "removed"
}

/**
 * `DocumentSyncStatus` represents the result of synchronizing the document with the server.
 * @public
 */
export declare enum DocumentSyncStatus {
    /**
     * `Synced` means that document synced successfully.
     */
    Synced = "synced",
    /**
     * `SyncFiled` means that document synchronization has failed.
     */
    SyncFailed = "sync-failed"
}

/**
 * `EditOpInfo` represents the information of the edit operation.
 */
export declare type EditOpInfo = {
    type: 'edit';
    path: string;
    from: number;
    to: number;
    value: {
        attributes: Indexable;
        content: string;
    };
};

/**
 * `ElementNode` represents an element node. It has an attributes and children.
 */
export declare type ElementNode<A extends Indexable = Indexable> = {
    type: TreeNodeType;
    attributes?: A;
    children: Array<TreeNode>;
};

/**
 * ElementRHT is a hashtable with logical clock(Replicated hashtable)
 *
 */
declare class ElementRHT {
    private nodeMapByKey;
    private nodeMapByCreatedAt;
    constructor();
    /**
     * `create` creates an instance of ElementRHT.
     */
    static create(): ElementRHT;
    /**
     * `set` sets the value of the given key.
     */
    set(key: string, value: CRDTElement, executedAt: TimeTicket): CRDTElement | undefined;
    /**
     * `delete` deletes the Element of the given key.
     */
    delete(createdAt: TimeTicket, executedAt: TimeTicket): CRDTElement;
    /**
     * `subPathOf` returns the sub path of the given element.
     */
    subPathOf(createdAt: TimeTicket): string | undefined;
    /**
     * `purge` physically purge child element.
     */
    purge(element: CRDTElement): void;
    /**
     * `deleteByKey` deletes the Element of the given key and removed time.
     */
    deleteByKey(key: string, removedAt: TimeTicket): CRDTElement | undefined;
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key: string): boolean;
    /**
     * `getByID` returns the node of the given createdAt.
     */
    getByID(createdAt: TimeTicket): ElementRHTNode | undefined;
    /**
     * `get` returns the node of the given key.
     */
    get(key: string): ElementRHTNode | undefined;
    [Symbol.iterator](): IterableIterator<ElementRHTNode>;
}

/**
 * `ElementRHTNode` is a node of ElementRHT.
 */
declare class ElementRHTNode {
    private strKey;
    private value;
    constructor(strKey: string, value: CRDTElement);
    /**
     * `of` creates a instance of ElementRHTNode.
     */
    static of(strKey: string, value: CRDTElement): ElementRHTNode;
    /**
     * `isRemoved` checks whether this value was removed.
     */
    isRemoved(): boolean;
    /**
     * `getStrKey` returns the key of this node.
     */
    getStrKey(): string;
    /**
     * `getValue` return the value(element) of this node
     */
    getValue(): CRDTElement;
    /**
     * `remove` removes a value base on removing time.
     */
    remove(removedAt: TimeTicket): boolean;
}

export declare type ErrorFn = (error: Error) => void;

/**
 * `EventSourceDevPanel` is the name of the source representing messages
 *  from the Devtools panel.
 */
export declare const EventSourceDevPanel = "yorkie-devtools-panel";

/**
 * `EventSourceSDK` is the name of the source representing messages
 * from the SDK.
 */
export declare const EventSourceSDK = "yorkie-devtools-sdk";

/**
 * `ExecutionResult` represents the result of operation execution.
 */
declare type ExecutionResult = {
    opInfos: Array<OperationInfo>;
    reverseOp?: Operation;
};

declare type Executor<T> = (observer: Observer<T>) => void;

/**
 * `fromChangePack` converts the given Protobuf format to model format.
 */
declare function fromChangePack<P extends Indexable>(pbPack: ChangePack_2): ChangePack<P>;

/**
 * `fromChanges` converts the given Protobuf format to model format.
 */
declare function fromChanges<P extends Indexable>(pbChanges: Array<Change_2>): Array<Change<P>>;

/**
 * `fromPresence` converts the given Protobuf format to model format.
 */
declare function fromPresence<P extends Indexable>(pbPresence: Presence_2): P;

export declare type FullPanelToSDKMessage = PanelToSDKMessage & {
    source: 'yorkie-devtools-panel';
};

export declare type FullSDKToPanelMessage = SDKToPanelMessage & {
    source: 'yorkie-devtools-sdk';
};

/**
 * `GCChild` is an interface for the child of the garbage collection target.
 */
declare interface GCChild {
    toIDString(): string;
    getRemovedAt(): TimeTicket | undefined;
}

/**
 * `GCPair` is a structure that represents a pair of parent and child for garbage
 * collection.
 */
declare type GCPair = {
    parent: GCParent;
    child: GCChild;
};

/**
 * `GCParent` is an interface for the parent of the garbage collection target.
 */
declare interface GCParent {
    purge(node: GCChild): void;
}

/**
 * `hexToBytes` converts the given hex string to byte array.
 */
declare function hexToBytes(hex: string): Uint8Array;

/**
 * `History` is a class that stores the history of the document.
 */
declare class History_2<P extends Indexable> {
    private undoStack;
    private redoStack;
    /**
     * `hasUndo` returns true if there are undo operations.
     */
    hasUndo(): boolean;
    /**
     * `hasRedo` returns true if there are redo operations.
     */
    hasRedo(): boolean;
    /**
     * `pushUndo` pushes new undo operations of a change to undo stack.
     */
    pushUndo(undoOps: Array<HistoryOperation<P>>): void;
    /**
     * `popUndo` pops the last undo operations of a change from undo stack.
     */
    popUndo(): Array<HistoryOperation<P>> | undefined;
    /**
     * `pushRedo` pushes new redo operations of a change to redo stack.
     */
    pushRedo(redoOps: Array<HistoryOperation<P>>): void;
    /**
     * `popRedo` pops the last redo operations of a change from redo stack.
     */
    popRedo(): Array<HistoryOperation<P>> | undefined;
    /**
     * `clearRedo` flushes remaining redo operations.
     */
    clearRedo(): void;
    /**
     * `getUndoStackForTest` returns the undo stack for test.
     */
    getUndoStackForTest(): Array<Array<HistoryOperation<P>>>;
    /**
     * `getRedoStackForTest` returns the redo stack for test.
     */
    getRedoStackForTest(): Array<Array<HistoryOperation<P>>>;
}

/**
 * `HistoryOperation` is a type of history operation.
 */
declare type HistoryOperation<P extends Indexable> = Operation | {
    type: 'presence';
    value: Partial<P>;
};

/**
 * `IncreaseOpInfo` represents the information of the increase operation.
 */
export declare type IncreaseOpInfo = {
    type: 'increase';
    path: string;
    value: number;
};

/**
 * Indexable key, value
 * @public
 */
export declare type Indexable = Record<string, any>;

/**
 * `IndexTree` is a tree structure for linear indexing.
 */
declare class IndexTree<T extends IndexTreeNode<T>> {
    private root;
    constructor(root: T);
    /**
     * `tokensBetween` returns the tokens between the given range.
     */
    tokensBetween(from: number, to: number, callback: (token: TreeToken<T>, ended: boolean) => void): void;
    /**
     * `traverse` traverses the tree with postorder traversal.
     */
    traverse(callback: (node: T) => void): void;
    /**
     * `traverseAll` traverses the whole tree (include tombstones) with postorder traversal.
     */
    traverseAll(callback: (node: T) => void): void;
    /**
     * findTreePos finds the position of the given index in the tree.
     */
    findTreePos(index: number, preferText?: boolean): TreePos<T>;
    /**
     * `treePosToPath` returns path from given treePos
     */
    treePosToPath(treePos: TreePos<T>): number[];
    /**
     * `pathToIndex` returns index from given path
     */
    pathToIndex(path: Array<number>): number;
    /**
     * `pathToTreePos` returns treePos from given path
     */
    pathToTreePos(path: Array<number>): TreePos<T>;
    /**
     * `getRoot` returns the root node of the tree.
     */
    getRoot(): T;
    /**
     * `getSize` returns the size of the tree.
     */
    get size(): number;
    /**
     * `findPostorderRight` finds right node of the given tree position with
     *  postorder traversal.
     */
    findPostorderRight(treePos: TreePos<T>): T | undefined;
    /**
     * `indexOf` returns the index of the given tree position.
     */
    indexOf(pos: TreePos<T>): number;
    /**
     * `indexToPath` returns the path of the given index.
     */
    indexToPath(index: number): Array<number>;
}

/**
 * `IndexTreeNode` is the node of IndexTree. It is used to represent the
 * document of text-based editors.
 */
declare abstract class IndexTreeNode<T extends IndexTreeNode<T>> {
    type: TreeNodeType;
    parent?: T;
    _children: Array<T>;
    size: number;
    constructor(type: TreeNodeType, children?: Array<T>);
    /**
     * `updateAncestorsSize` updates the size of the ancestors. It is used when
     * the size of the node is changed.
     */
    updateAncestorsSize(): void;
    /**
     * `updateDescendantsSize` updates the size of the descendants. It is used when
     * the tree is newly created and the size of the descendants is not calculated.
     */
    updateDescendantsSize(): number;
    /**
     * `isText` returns true if the node is a text node.
     */
    get isText(): boolean;
    /**
     * `paddedSize` returns the size of the node including padding size.
     */
    get paddedSize(): number;
    /**
     * `isAncenstorOf` returns true if the node is an ancestor of the given node.
     */
    isAncestorOf(node: T): boolean;
    /**
     * `nextSibling` returns the next sibling of the node.
     */
    get nextSibling(): T | undefined;
    /**
     * `prevSibling` returns the previous sibling of the node.
     */
    get prevSibling(): T | undefined;
    /**
     * `isRemoved` returns true if the node is removed.
     */
    abstract get isRemoved(): boolean;
    /**
     * `cloneText` clones the text node with the given id and value.
     */
    abstract cloneText(offset: number): T;
    /**
     * `cloneElement` clones the element node with the given issueTimeTicket
     * function and value.
     */
    abstract cloneElement(issueTimeTicket: () => TimeTicket): T;
    /**
     * `value` returns the value of the node.
     */
    abstract get value(): string;
    /**
     * `value` sets the value of the node.
     */
    abstract set value(v: string);
    /**
     * `splitText` splits the given node at the given offset.
     */
    splitText(offset: number, absOffset: number): T | undefined;
    /**
     * `children` returns the children of the node.
     */
    get children(): Array<T>;
    /**
     * `allChildren` returns all the children of the node including tombstone nodes.
     * It returns the shallow copy of the children.
     */
    get allChildren(): Array<T>;
    /**
     * `hasTextChild` returns true if the node's children consist of only text children.
     */
    hasTextChild(): boolean;
    /**
     * `append` appends the given nodes to the children.
     */
    append(...newNode: Array<T>): void;
    /**
     * `prepend` prepends the given nodes to the children. It is only used
     * for creating a new node from snapshot.
     */
    prepend(...newNode: Array<T>): void;
    /**
     * `insertBefore` inserts the given node before the given child.
     */
    insertBefore(newNode: T, referenceNode: T): void;
    /**
     * `insertAfter` inserts the given node after the given child.
     */
    insertAfter(newNode: T, referenceNode: T): void;
    /**
     * `insertAt` inserts the given node at the given offset.
     */
    insertAt(newNode: T, offset: number): void;
    /**
     * `removeChild` removes the given child.
     */
    removeChild(child: T): void;
    /**
     * `splitElement` splits the given element at the given offset.
     */
    splitElement(offset: number, issueTimeTicket: () => TimeTicket): T | undefined;
    /**
     * `insertAfterInternal` inserts the given node after the given child.
     * This method does not update the size of the ancestors.
     */
    insertAfterInternal(newNode: T, referenceNode: T): void;
    /**
     * `insertAtInternal` inserts the given node at the given index.
     * This method does not update the size of the ancestors.
     */
    insertAtInternal(newNode: T, offset: number): void;
    /**
     * findOffset returns the offset of the given node in the children.
     * It excludes the removed nodes.
     */
    findOffset(node: T): number;
    /**
     * `findBranchOffset` returns offset of the given descendant node in this node.
     * If the given node is not a descendant of this node, it returns -1.
     */
    findBranchOffset(node: T): number;
}

export declare interface InitializedEvent<P extends Indexable> extends BaseDocEvent {
    type: DocEventType.Initialized;
    source: OpSource.Local;
    value: Array<{
        clientID: ActorID;
        presence: P;
    }>;
}

/**
 * `Json` represents a JSON value.
 *
 * TODO(hackerwins): We need to replace `Indexable` with `Json`.
 */
declare type Json = string | number | boolean | null | {
    [key: string]: Json;
} | Array<Json>;

/**
 * `JSONArray` represents JSON array, but unlike regular JSON, it has time
 * tickets created by a logical clock to resolve conflicts.
 */
export declare type JSONArray<T> = {
    /**
     * `getID` returns the ID, `TimeTicket` of this Object.
     */
    getID?(): TimeTicket;
    /**
     * `getElementByID` returns the element for the given ID.
     */
    getElementByID?(createdAt: TimeTicket): WrappedElement<T>;
    /**
     * `getElementByIndex` returns the element for the given index.
     */
    getElementByIndex?(index: number): WrappedElement<T>;
    /**
     * `getLast` returns the last element of this array.
     */
    getLast?(): WrappedElement<T>;
    /**
     * `deleteByID` deletes the element of the given ID.
     */
    deleteByID?(createdAt: TimeTicket): WrappedElement<T>;
    /**
     * `insertBefore` inserts a value before the given next element.
     */
    insertBefore?(nextID: TimeTicket, value: any): WrappedElement<T>;
    /**
     * `insertAfter` inserts a value after the given previous element.
     */
    insertAfter?(prevID: TimeTicket, value: any): WrappedElement<T>;
    /**
     * `moveBefore` moves the element before the given next element.
     */
    moveBefore?(nextID: TimeTicket, id: TimeTicket): void;
    /**
     * `moveAfter` moves the element after the given previous element.
     */
    moveAfter?(prevID: TimeTicket, id: TimeTicket): void;
    /**
     * `moveFront` moves the element before the first element.
     */
    moveFront?(id: TimeTicket): void;
    /**
     * `moveLast` moves the element after the last element.
     */
    moveLast?(id: TimeTicket): void;
    /**
     * `toTestString` returns a String containing the meta data of the node
     * for debugging purpose.
     */
    toTestString?(): string;
    /* Excluded from this release type: toJSForTest */
} & Array<T>;

/**
 * `JSONElement` is a wrapper for `CRDTElement` that provides users with an
 * easy-to-use interface for manipulating `Document`s.
 */
export declare type JSONElement<T = unknown, A extends Indexable = Indexable> = PrimitiveValue | JSONObject<T> | JSONArray<T> | Text_2<A> | Counter | Tree;

/**
 * `JSONElement` represents the result of `Element.toJSForTest()`.
 */
declare type JSONElement_2 = {
    type: JSONElementType;
    key?: string;
    value: JSONElementValue;
    createdAt: string;
};

/**
 * @generated from message yorkie.v1.JSONElementSimple
 */
declare class JSONElementSimple extends Message<JSONElementSimple> {
    /**
     * @generated from field: yorkie.v1.TimeTicket created_at = 1;
     */
    createdAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TimeTicket moved_at = 2;
     */
    movedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TimeTicket removed_at = 3;
     */
    removedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.ValueType type = 4;
     */
    type: ValueType;

    /**
     * @generated from field: bytes value = 5;
     */
    value: Uint8Array;

    constructor(data?: PartialMessage<JSONElementSimple>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.JSONElementSimple";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JSONElementSimple;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JSONElementSimple;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JSONElementSimple;

    static equals(a: JSONElementSimple | PlainMessage<JSONElementSimple> | undefined, b: JSONElementSimple | PlainMessage<JSONElementSimple> | undefined): boolean;
}

declare type JSONElementType = 'YORKIE_PRIMITIVE' | 'YORKIE_COUNTER' | 'YORKIE_OBJECT' | 'YORKIE_ARRAY' | 'YORKIE_TEXT' | 'YORKIE_TREE';

/**
 * `ElementValue` represents the result of `Element.toJSForTest()`.
 *
 * NOTE(chacha912): Json type is used to represent the result of
 * `Text.toJSForTest()` and `Tree.toJSForTest()`.
 */
declare type JSONElementValue = PrimitiveValue | CounterValue | ContainerValue | Json;

/**
 * `JSONObject` represents a JSON object, but unlike regular JSON, it has time
 * tickets created by a logical clock to resolve conflicts.
 */
export declare type JSONObject<T> = {
    /**
     * `getID` returns the ID(time ticket) of this Object.
     */
    getID?(): TimeTicket;
    /**
     * `toJSON` returns the JSON encoding of this object.
     */
    toJSON?(): string;
    /**
     * `toJS` returns the JSON object of this object.
     */
    toJS?(): T;
    /* Excluded from this release type: toJSForTest */
} & T;

/**
 * `LeafElement` is a leaf element of JSONElement.
 */
declare type LeafElement = PrimitiveValue | Primitive | Text_2 | Counter | Tree;

/**
 * `LocalChangeEvent` is an event that occurs when the document is changed
 * by local changes.
 *
 * @public
 */
export declare interface LocalChangeEvent<T = OperationInfo, P extends Indexable = Indexable> extends BaseDocEvent {
    /**
     * enum {@link DocEventType}.LocalChange
     */
    type: DocEventType.LocalChange;
    source: OpSource.Local | OpSource.UndoRedo;
    value: ChangeInfo<T>;
    rawChange?: ChangeStruct<P>;
}

export declare enum LogLevel {
    Trivial = 0,
    Debug = 1,
    Info = 2,
    Warn = 3,
    Error = 4,
    Fatal = 5
}

/**
 * `MoveOpInfo` represents the information of the move operation.
 */
export declare type MoveOpInfo = {
    type: 'move';
    path: string;
    previousIndex: number;
    index: number;
};

export declare type NextFn<T> = (value: T) => void;

/**
 * @generated from message yorkie.v1.NodeAttr
 */
declare class NodeAttr extends Message<NodeAttr> {
    /**
     * @generated from field: string value = 1;
     */
    value: string;

    /**
     * @generated from field: yorkie.v1.TimeTicket updated_at = 2;
     */
    updatedAt?: TimeTicket_2;

    /**
     * @generated from field: bool is_removed = 3;
     */
    isRemoved: boolean;

    constructor(data?: PartialMessage<NodeAttr>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.NodeAttr";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeAttr;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeAttr;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeAttr;

    static equals(a: NodeAttr | PlainMessage<NodeAttr> | undefined, b: NodeAttr | PlainMessage<NodeAttr> | undefined): boolean;
}

/**
 * `ObjectOperationInfo` represents the OperationInfo for the JSONObject.
 */
export declare type ObjectOperationInfo = SetOpInfo | RemoveOpInfo;

/**
 * `objectToBytes` converts the given JSONObject to byte array.
 */
declare function objectToBytes(obj: CRDTObject): Uint8Array;

export declare interface Observable<T> {
    subscribe: SubscribeFn<T>;
    getProxy?: () => ObserverProxy<T>;
}

export declare interface Observer<T> {
    next: NextFn<T>;
    error?: ErrorFn;
    complete?: CompleteFn;
}

/**
 * `ObserverProxy` is proxy of `Observer`.
 */
declare class ObserverProxy<T> implements Observer<T> {
    finalized: boolean;
    private observers;
    private finalError?;
    constructor(executor: Executor<T>);
    /**
     * `next` iterates next observer synchronously.
     */
    next(value: T): void;
    /**
     * `error` invoke error.
     */
    error(error: Error): void;
    /**
     * `complete` completes observer.
     */
    complete(): void;
    /**
     * `subscribe` is a function for subscribing observer.
     */
    subscribe(nextOrObserver: Observer<T> | NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    private unsubscribeOne;
    private forEachObserver;
    private sendOne;
    private close;
}

/**
 * `Operation` represents an operation to be executed on a document.
 */
declare abstract class Operation {
    private parentCreatedAt;
    private executedAt?;
    constructor(parentCreatedAt: TimeTicket, executedAt?: TimeTicket);
    /**
     * `getParentCreatedAt` returns the creation time of the target element to
     * execute the operation.
     */
    getParentCreatedAt(): TimeTicket;
    /**
     * `getExecutedAt` returns execution time of this operation.
     */
    getExecutedAt(): TimeTicket;
    /**
     * `setActor` sets the given actor to this operation.
     */
    setActor(actorID: ActorID): void;
    /**
     * `setExecutedAt` sets the executedAt.
     */
    setExecutedAt(executedAt: TimeTicket): void;
    /**
     * `getEffectedCreatedAt` returns the creation time of the effected element.
     */
    abstract getEffectedCreatedAt(): TimeTicket;
    /**
     * `toTestString` returns a string containing the meta data for debugging purpose.
     */
    abstract toTestString(): string;
    /**
     * `execute` executes this operation on the given `CRDTRoot`.
     */
    abstract execute(root: CRDTRoot, source: OpSource): ExecutionResult | undefined;
}

/**
 * @generated from message yorkie.v1.Operation
 */
declare class Operation_2 extends Message<Operation_2> {
    /**
     * @generated from oneof yorkie.v1.Operation.body
     */
    body: {
        /**
         * @generated from field: yorkie.v1.Operation.Set set = 1;
         */
        value: Operation_Set;
        case: "set";
    } | {
        /**
         * @generated from field: yorkie.v1.Operation.Add add = 2;
         */
        value: Operation_Add;
        case: "add";
    } | {
        /**
         * @generated from field: yorkie.v1.Operation.Move move = 3;
         */
        value: Operation_Move;
        case: "move";
    } | {
        /**
         * @generated from field: yorkie.v1.Operation.Remove remove = 4;
         */
        value: Operation_Remove;
        case: "remove";
    } | {
        /**
         * @generated from field: yorkie.v1.Operation.Edit edit = 5;
         */
        value: Operation_Edit;
        case: "edit";
    } | {
        /**
         * @generated from field: yorkie.v1.Operation.Select select = 6;
         */
        value: Operation_Select;
        case: "select";
    } | {
        /**
         * @generated from field: yorkie.v1.Operation.Style style = 7;
         */
        value: Operation_Style;
        case: "style";
    } | {
        /**
         * @generated from field: yorkie.v1.Operation.Increase increase = 8;
         */
        value: Operation_Increase;
        case: "increase";
    } | {
        /**
         * @generated from field: yorkie.v1.Operation.TreeEdit tree_edit = 9;
         */
        value: Operation_TreeEdit;
        case: "treeEdit";
    } | {
        /**
         * @generated from field: yorkie.v1.Operation.TreeStyle tree_style = 10;
         */
        value: Operation_TreeStyle;
        case: "treeStyle";
    } | { case: undefined; value?: undefined };

    constructor(data?: PartialMessage<Operation_2>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Operation";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation_2;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation_2;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation_2;

    static equals(a: Operation_2 | PlainMessage<Operation_2> | undefined, b: Operation_2 | PlainMessage<Operation_2> | undefined): boolean;
}

/**
 * @generated from message yorkie.v1.Operation.Add
 */
declare class Operation_Add extends Message<Operation_Add> {
    /**
     * @generated from field: yorkie.v1.TimeTicket parent_created_at = 1;
     */
    parentCreatedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TimeTicket prev_created_at = 2;
     */
    prevCreatedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.JSONElementSimple value = 3;
     */
    value?: JSONElementSimple;

    /**
     * @generated from field: yorkie.v1.TimeTicket executed_at = 4;
     */
    executedAt?: TimeTicket_2;

    constructor(data?: PartialMessage<Operation_Add>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Operation.Add";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation_Add;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation_Add;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation_Add;

    static equals(a: Operation_Add | PlainMessage<Operation_Add> | undefined, b: Operation_Add | PlainMessage<Operation_Add> | undefined): boolean;
}

/**
 * @generated from message yorkie.v1.Operation.Edit
 */
declare class Operation_Edit extends Message<Operation_Edit> {
    /**
     * @generated from field: yorkie.v1.TimeTicket parent_created_at = 1;
     */
    parentCreatedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TextNodePos from = 2;
     */
    from?: TextNodePos;

    /**
     * @generated from field: yorkie.v1.TextNodePos to = 3;
     */
    to?: TextNodePos;

    /**
     * @generated from field: map<string, yorkie.v1.TimeTicket> created_at_map_by_actor = 4;
     */
    createdAtMapByActor: { [key: string]: TimeTicket_2 };

    /**
     * @generated from field: string content = 5;
     */
    content: string;

    /**
     * @generated from field: yorkie.v1.TimeTicket executed_at = 6;
     */
    executedAt?: TimeTicket_2;

    /**
     * @generated from field: map<string, string> attributes = 7;
     */
    attributes: { [key: string]: string };

    constructor(data?: PartialMessage<Operation_Edit>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Operation.Edit";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation_Edit;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation_Edit;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation_Edit;

    static equals(a: Operation_Edit | PlainMessage<Operation_Edit> | undefined, b: Operation_Edit | PlainMessage<Operation_Edit> | undefined): boolean;
}

/**
 * @generated from message yorkie.v1.Operation.Increase
 */
declare class Operation_Increase extends Message<Operation_Increase> {
    /**
     * @generated from field: yorkie.v1.TimeTicket parent_created_at = 1;
     */
    parentCreatedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.JSONElementSimple value = 2;
     */
    value?: JSONElementSimple;

    /**
     * @generated from field: yorkie.v1.TimeTicket executed_at = 3;
     */
    executedAt?: TimeTicket_2;

    constructor(data?: PartialMessage<Operation_Increase>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Operation.Increase";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation_Increase;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation_Increase;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation_Increase;

    static equals(a: Operation_Increase | PlainMessage<Operation_Increase> | undefined, b: Operation_Increase | PlainMessage<Operation_Increase> | undefined): boolean;
}

/**
 * @generated from message yorkie.v1.Operation.Move
 */
declare class Operation_Move extends Message<Operation_Move> {
    /**
     * @generated from field: yorkie.v1.TimeTicket parent_created_at = 1;
     */
    parentCreatedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TimeTicket prev_created_at = 2;
     */
    prevCreatedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TimeTicket created_at = 3;
     */
    createdAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TimeTicket executed_at = 4;
     */
    executedAt?: TimeTicket_2;

    constructor(data?: PartialMessage<Operation_Move>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Operation.Move";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation_Move;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation_Move;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation_Move;

    static equals(a: Operation_Move | PlainMessage<Operation_Move> | undefined, b: Operation_Move | PlainMessage<Operation_Move> | undefined): boolean;
}

/**
 * @generated from message yorkie.v1.Operation.Remove
 */
declare class Operation_Remove extends Message<Operation_Remove> {
    /**
     * @generated from field: yorkie.v1.TimeTicket parent_created_at = 1;
     */
    parentCreatedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TimeTicket created_at = 2;
     */
    createdAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TimeTicket executed_at = 3;
     */
    executedAt?: TimeTicket_2;

    constructor(data?: PartialMessage<Operation_Remove>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Operation.Remove";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation_Remove;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation_Remove;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation_Remove;

    static equals(a: Operation_Remove | PlainMessage<Operation_Remove> | undefined, b: Operation_Remove | PlainMessage<Operation_Remove> | undefined): boolean;
}

/**
 * NOTE(hackerwins): Select Operation is not used in the current version.
 * In the previous version, it was used to represent selection of Text.
 * However, it has been replaced by Presence now. It is retained for backward
 * compatibility purposes.
 *
 * @generated from message yorkie.v1.Operation.Select
 */
declare class Operation_Select extends Message<Operation_Select> {
    /**
     * @generated from field: yorkie.v1.TimeTicket parent_created_at = 1;
     */
    parentCreatedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TextNodePos from = 2;
     */
    from?: TextNodePos;

    /**
     * @generated from field: yorkie.v1.TextNodePos to = 3;
     */
    to?: TextNodePos;

    /**
     * @generated from field: yorkie.v1.TimeTicket executed_at = 4;
     */
    executedAt?: TimeTicket_2;

    constructor(data?: PartialMessage<Operation_Select>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Operation.Select";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation_Select;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation_Select;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation_Select;

    static equals(a: Operation_Select | PlainMessage<Operation_Select> | undefined, b: Operation_Select | PlainMessage<Operation_Select> | undefined): boolean;
}

/**
 * @generated from message yorkie.v1.Operation.Set
 */
declare class Operation_Set extends Message<Operation_Set> {
    /**
     * @generated from field: yorkie.v1.TimeTicket parent_created_at = 1;
     */
    parentCreatedAt?: TimeTicket_2;

    /**
     * @generated from field: string key = 2;
     */
    key: string;

    /**
     * @generated from field: yorkie.v1.JSONElementSimple value = 3;
     */
    value?: JSONElementSimple;

    /**
     * @generated from field: yorkie.v1.TimeTicket executed_at = 4;
     */
    executedAt?: TimeTicket_2;

    constructor(data?: PartialMessage<Operation_Set>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Operation.Set";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation_Set;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation_Set;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation_Set;

    static equals(a: Operation_Set | PlainMessage<Operation_Set> | undefined, b: Operation_Set | PlainMessage<Operation_Set> | undefined): boolean;
}

/**
 * @generated from message yorkie.v1.Operation.Style
 */
declare class Operation_Style extends Message<Operation_Style> {
    /**
     * @generated from field: yorkie.v1.TimeTicket parent_created_at = 1;
     */
    parentCreatedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TextNodePos from = 2;
     */
    from?: TextNodePos;

    /**
     * @generated from field: yorkie.v1.TextNodePos to = 3;
     */
    to?: TextNodePos;

    /**
     * @generated from field: map<string, string> attributes = 4;
     */
    attributes: { [key: string]: string };

    /**
     * @generated from field: yorkie.v1.TimeTicket executed_at = 5;
     */
    executedAt?: TimeTicket_2;

    /**
     * @generated from field: map<string, yorkie.v1.TimeTicket> created_at_map_by_actor = 6;
     */
    createdAtMapByActor: { [key: string]: TimeTicket_2 };

    constructor(data?: PartialMessage<Operation_Style>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Operation.Style";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation_Style;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation_Style;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation_Style;

    static equals(a: Operation_Style | PlainMessage<Operation_Style> | undefined, b: Operation_Style | PlainMessage<Operation_Style> | undefined): boolean;
}

/**
 * @generated from message yorkie.v1.Operation.TreeEdit
 */
declare class Operation_TreeEdit extends Message<Operation_TreeEdit> {
    /**
     * @generated from field: yorkie.v1.TimeTicket parent_created_at = 1;
     */
    parentCreatedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TreePos from = 2;
     */
    from?: TreePos_2;

    /**
     * @generated from field: yorkie.v1.TreePos to = 3;
     */
    to?: TreePos_2;

    /**
     * @generated from field: map<string, yorkie.v1.TimeTicket> created_at_map_by_actor = 4;
     */
    createdAtMapByActor: { [key: string]: TimeTicket_2 };

    /**
     * @generated from field: repeated yorkie.v1.TreeNodes contents = 5;
     */
    contents: TreeNodes[];

    /**
     * @generated from field: int32 split_level = 7;
     */
    splitLevel: number;

    /**
     * @generated from field: yorkie.v1.TimeTicket executed_at = 6;
     */
    executedAt?: TimeTicket_2;

    constructor(data?: PartialMessage<Operation_TreeEdit>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Operation.TreeEdit";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation_TreeEdit;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation_TreeEdit;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation_TreeEdit;

    static equals(a: Operation_TreeEdit | PlainMessage<Operation_TreeEdit> | undefined, b: Operation_TreeEdit | PlainMessage<Operation_TreeEdit> | undefined): boolean;
}

/**
 * @generated from message yorkie.v1.Operation.TreeStyle
 */
declare class Operation_TreeStyle extends Message<Operation_TreeStyle> {
    /**
     * @generated from field: yorkie.v1.TimeTicket parent_created_at = 1;
     */
    parentCreatedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TreePos from = 2;
     */
    from?: TreePos_2;

    /**
     * @generated from field: yorkie.v1.TreePos to = 3;
     */
    to?: TreePos_2;

    /**
     * @generated from field: map<string, string> attributes = 4;
     */
    attributes: { [key: string]: string };

    /**
     * @generated from field: yorkie.v1.TimeTicket executed_at = 5;
     */
    executedAt?: TimeTicket_2;

    /**
     * @generated from field: repeated string attributes_to_remove = 6;
     */
    attributesToRemove: string[];

    /**
     * @generated from field: map<string, yorkie.v1.TimeTicket> created_at_map_by_actor = 7;
     */
    createdAtMapByActor: { [key: string]: TimeTicket_2 };

    constructor(data?: PartialMessage<Operation_TreeStyle>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Operation.TreeStyle";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation_TreeStyle;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation_TreeStyle;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation_TreeStyle;

    static equals(a: Operation_TreeStyle | PlainMessage<Operation_TreeStyle> | undefined, b: Operation_TreeStyle | PlainMessage<Operation_TreeStyle> | undefined): boolean;
}

/**
 * `OperationInfo` represents the information of an operation.
 * It is used to inform to the user what kind of operation was executed.
 */
export declare type OperationInfo = TextOperationInfo | CounterOperationInfo | ArrayOperationInfo | ObjectOperationInfo | TreeOperationInfo;

/**
 * `OperationInfoOf` represents the type of the operation info of the given
 * path in the Document.subscribe. It is used to remove the `$.` prefix.
 */
declare type OperationInfoOf<TDocument, TKey extends string = '', TDepth extends number = 10> = TKey extends `$.${infer TPath}` ? OperationInfoOfInternal<TDocument, TPath, TDepth> : OperationInfoOfInternal<TDocument, TKey, TDepth>;

/**
 * `OperationInfoOfElement` represents the type of the operation info of the given element.
 */
declare type OperationInfoOfElement<TElement> = TElement extends Text_2 ? TextOperationInfo : TElement extends Counter ? CounterOperationInfo : TElement extends Tree ? TreeOperationInfo : TElement extends BaseArray<any> ? ArrayOperationInfo : TElement extends BaseObject<any> ? ObjectOperationInfo : OperationInfo;

/**
 * `OperationInfoOfInternal` represents the type of the operation info of the
 * given path in the Document.subscribe.
 *
 * TODO(easylogic): If the parent is optional, children cannot be inferred.
 * TODO(easylogic): Currently, the below cases of Document.subscribe are confused.
 * ```
 *  type DocType = { obj: { key: string }, text: Text }
 *  $.obj.text ->> obj's operations
 *  $.text ->> text's operations
 * ```
 */
declare type OperationInfoOfInternal<TElement, TKeyOrPath, TDepth extends number = 0> = TDepth extends 0 ? TElement : TKeyOrPath extends `${infer TFirst}.${infer TRest}` ? TFirst extends keyof TElement ? TElement[TFirst] extends BaseArray<unknown> ? OperationInfoOfInternal<TElement[TFirst], number, DecreasedDepthOf<TDepth>> : OperationInfoOfInternal<TElement[TFirst], TRest, DecreasedDepthOf<TDepth>> : OperationInfo : TKeyOrPath extends keyof TElement ? TElement[TKeyOrPath] extends BaseArray<unknown> ? ArrayOperationInfo : OperationInfoOfElement<TElement[TKeyOrPath]> : OperationInfo;

/**
 * `OpSource` represents the source of the operation. It is used to handle
 * corner cases in the operations created by undo/redo allow the removed
 * elements when executing them.
 */
export declare enum OpSource {
    Local = "local",
    Remote = "remote",
    UndoRedo = "undoredo"
}

/**
 * PanelToSDKMessage is a message sent from the Devtools panel to the SDK.
 */
export declare type PanelToSDKMessage = 
/**
* Informs the SDK that the panel is available.
*/
    {
    msg: 'devtools::connect';
}
/**
* Informs the SDK that the panel is not available.
*/
| {
    msg: 'devtools::disconnect';
}
/**
* Informs the SDK that the panel is interested in receiving the "event" for the document,
* starting with the initial "full sync" event.
*/
| {
    msg: 'devtools::subscribe';
    docKey: string;
};

/**
 * `PathOf` represents the type of the all possible paths in the Document.subscribe.
 */
declare type PathOf<TDocument, Depth extends number = 10> = PathOfInternal<TDocument, '$.', Depth>;

/**
 * `PathOfInternal` represents the type of the path of the given element.
 */
declare type PathOfInternal<TElement, Prefix extends string = '', Depth extends number = 0> = Depth extends 0 ? Prefix : TElement extends Record<string, any> ? {
    [TKey in keyof TElement]: TElement[TKey] extends LeafElement ? `${Prefix}${TKey & string}` : TElement[TKey] extends BaseArray<infer TArrayElement> ? `${Prefix}${TKey & string}` | `${Prefix}${TKey & string}.${number}` | PathOfInternal<TArrayElement, `${Prefix}${TKey & string}.${number}.`, DecreasedDepthOf<Depth>> : `${Prefix}${TKey & string}` | PathOfInternal<TElement[TKey], `${Prefix}${TKey & string}.`, DecreasedDepthOf<Depth>>;
}[keyof TElement] : Prefix extends `${infer TRest}.` ? TRest : Prefix;

/**
 * `Presence` represents a proxy for the Presence to be manipulated from the outside.
 */
declare class Presence<P extends Indexable> {
    private context;
    private presence;
    constructor(changeContext: ChangeContext, presence: P);
    /**
     * `set` updates the presence based on the partial presence.
     */
    set(presence: Partial<P>, option?: {
        addToHistory: boolean;
    }): void;
    /**
     * `get` returns the presence value of the given key.
     */
    get<K extends keyof P>(key: K): P[K];
    /* Excluded from this release type: clear */
}

/**
 * @generated from message yorkie.v1.Presence
 */
declare class Presence_2 extends Message<Presence_2> {
    /**
     * @generated from field: map<string, string> data = 1;
     */
    data: { [key: string]: string };

    constructor(data?: PartialMessage<Presence_2>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.Presence";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Presence_2;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Presence_2;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Presence_2;

    static equals(a: Presence_2 | PlainMessage<Presence_2> | undefined, b: Presence_2 | PlainMessage<Presence_2> | undefined): boolean;
}

/**
 * `PresenceChange` represents the change of presence.
 */
declare type PresenceChange<P extends Indexable> = {
    type: PresenceChangeType.Put;
    presence: P;
} | {
    type: PresenceChangeType.Clear;
};

/**
 * @generated from message yorkie.v1.PresenceChange
 */
declare class PresenceChange_2 extends Message<PresenceChange_2> {
    /**
     * @generated from field: yorkie.v1.PresenceChange.ChangeType type = 1;
     */
    type: PresenceChange_ChangeType;

    /**
     * @generated from field: yorkie.v1.Presence presence = 2;
     */
    presence?: Presence_2;

    constructor(data?: PartialMessage<PresenceChange_2>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.PresenceChange";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PresenceChange_2;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PresenceChange_2;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PresenceChange_2;

    static equals(a: PresenceChange_2 | PlainMessage<PresenceChange_2> | undefined, b: PresenceChange_2 | PlainMessage<PresenceChange_2> | undefined): boolean;
}

/**
 * @generated from enum yorkie.v1.PresenceChange.ChangeType
 */
declare enum PresenceChange_ChangeType {
    /**
     * @generated from enum value: CHANGE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,

    /**
     * @generated from enum value: CHANGE_TYPE_PUT = 1;
     */
    PUT = 1,

    /**
     * @generated from enum value: CHANGE_TYPE_DELETE = 2;
     */
    DELETE = 2,

    /**
     * @generated from enum value: CHANGE_TYPE_CLEAR = 3;
     */
    CLEAR = 3,
}

export declare interface PresenceChangedEvent<P extends Indexable> extends BaseDocEvent {
    type: DocEventType.PresenceChanged;
    source: OpSource;
    value: {
        clientID: ActorID;
        presence: P;
    };
}

/**
 * `PresenceChangeType` represents the type of presence change.
 */
declare enum PresenceChangeType {
    Put = "put",
    Clear = "clear"
}

/**
 * `Primitive` represents primitive data type including logical clock.
 * It has a type and a value.
 */
export declare class Primitive extends CRDTElement {
    private valueType;
    private value;
    constructor(value: PrimitiveValue, createdAt: TimeTicket);
    /**
     * `of` creates a new instance of Primitive.
     */
    static of(value: PrimitiveValue, createdAt: TimeTicket): Primitive;
    /**
     * `valueFromBytes` parses the given bytes into value.
     */
    static valueFromBytes(primitiveType: PrimitiveType, bytes: Uint8Array): PrimitiveValue;
    /**
     * `toJSON` returns the JSON encoding of the value.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of the value.
     */
    toSortedJSON(): string;
    /**
     * `toJSForTest` returns value with meta data for testing.
     */
    toJSForTest(): Devtools.JSONElement;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): Primitive;
    /**
     * `getType` returns the type of the value.
     */
    getType(): PrimitiveType;
    /**
     * `getPrimitiveType` returns the primitive type of the value.
     */
    static getPrimitiveType(value: unknown): PrimitiveType | undefined;
    /**
     * `isSupport` check if the given value is supported type.
     */
    static isSupport(value: unknown): boolean;
    /**
     * `isInteger` checks if the given number is integer.
     */
    static isInteger(num: number): boolean;
    /**
     * `isNumericType` checks numeric type by JSONPrimitive
     */
    isNumericType(): boolean;
    /**
     * `getValue` returns the value of Primitive.
     */
    getValue(): PrimitiveValue;
    /**
     * `toBytes` creates an array representing the value.
     */
    toBytes(): Uint8Array;
}

declare enum PrimitiveType {
    Null = 0,
    Boolean = 1,
    Integer = 2,
    Long = 3,
    Double = 4,
    String = 5,
    Bytes = 6,
    Date = 7
}

/**
 * `PrimitiveValue` represents a value of primitive type. Only values of type
 * included in `PrimitiveValue` can be set to the document.
 */
export declare type PrimitiveValue = null | boolean | number | default_2 | string | Uint8Array | Date;

/**
 * `RemoteChangeEvent` is an event that occurs when the document is changed
 * by remote changes.
 *
 * @public
 */
export declare interface RemoteChangeEvent<T = OperationInfo, P extends Indexable = Indexable> extends BaseDocEvent {
    /**
     * enum {@link DocEventType}.RemoteChange
     */
    type: DocEventType.RemoteChange;
    source: OpSource.Remote;
    value: ChangeInfo<T>;
    rawChange?: ChangeStruct<P>;
}

/**
 * `RemoveOpInfo` represents the information of the remove operation.
 */
export declare type RemoveOpInfo = {
    type: 'remove';
    path: string;
    key?: string;
    index?: number;
};

/**
 * `RGATreeSplit` is a block-based list with improved index-based lookup in RGA.
 * The difference from RGATreeList is that it has data on a block basis to
 * reduce the size of CRDT metadata. When an edit occurs on a block,
 * the block is split.
 *
 */
declare class RGATreeSplit<T extends RGATreeSplitValue> implements GCParent {
    private head;
    private treeByIndex;
    private treeByID;
    constructor();
    /**
     * `create` creates a instance RGATreeSplit.
     */
    static create<T extends RGATreeSplitValue>(): RGATreeSplit<T>;
    /**
     * `edit` does following steps
     * 1. split nodes with from and to
     * 2. delete between from and to
     * 3. insert a new node
     * 4. add removed node
     * @param range - range of RGATreeSplitNode
     * @param editedAt - edited time
     * @param value - value
     * @param maxCreatedAtMapByActor - maxCreatedAtMapByActor
     * @returns `[RGATreeSplitPos, Map<string, TimeTicket>, Array<GCPair>, Array<Change>]`
     */
    edit(range: RGATreeSplitPosRange, editedAt: TimeTicket, value?: T, maxCreatedAtMapByActor?: Map<string, TimeTicket>): [
    RGATreeSplitPos,
    Map<string, TimeTicket>,
    Array<GCPair>,
    Array<ValueChange<T>>
    ];
    /**
     * `indexToPos` finds RGATreeSplitPos of given offset.
     */
    indexToPos(idx: number): RGATreeSplitPos;
    /**
     * `findIndexesFromRange` finds indexes based on range.
     */
    findIndexesFromRange(range: RGATreeSplitPosRange): [number, number];
    /**
     * `posToIndex` converts the given position to index.
     */
    posToIndex(pos: RGATreeSplitPos, preferToLeft: boolean): number;
    /**
     * `findNode` finds node of given id.
     */
    findNode(id: RGATreeSplitNodeID): RGATreeSplitNode<T>;
    /**
     * `length` returns size of RGATreeSplit.
     */
    get length(): number;
    /**
     * `checkWeight` returns false when there is an incorrect weight node.
     * for debugging purpose.
     */
    checkWeight(): boolean;
    /**
     * `toString` returns the string encoding of this RGATreeSplit.
     */
    toString(): string;
    [Symbol.iterator](): IterableIterator<RGATreeSplitNode<T>>;
    /**
     * `getHead` returns head of RGATreeSplitNode.
     */
    getHead(): RGATreeSplitNode<T>;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): RGATreeSplit<T>;
    /**
     * `toTestString` returns a String containing the meta data of the node
     * for debugging purpose.
     */
    toTestString(): string;
    /**
     * `insertAfter` inserts the given node after the given previous node.
     */
    insertAfter(prevNode: RGATreeSplitNode<T>, newNode: RGATreeSplitNode<T>): RGATreeSplitNode<T>;
    /**
     * `findNodeWithSplit` splits and return nodes of the given position.
     */
    findNodeWithSplit(pos: RGATreeSplitPos, editedAt: TimeTicket): [RGATreeSplitNode<T>, RGATreeSplitNode<T>];
    private findFloorNodePreferToLeft;
    private findFloorNode;
    /**
     * `findBetween` returns nodes between fromNode and toNode.
     */
    findBetween(fromNode: RGATreeSplitNode<T>, toNode: RGATreeSplitNode<T>): Array<RGATreeSplitNode<T>>;
    private splitNode;
    private deleteNodes;
    private filterNodes;
    /**
     * `findEdgesOfCandidates` finds the edges outside `candidates`,
     * (which has not already been deleted, or be undefined but not yet implemented)
     * right edge is undefined means `candidates` contains the end of text.
     */
    private findEdgesOfCandidates;
    private makeChanges;
    /**
     * `deleteIndexNodes` clears the index nodes of the given deletion boundaries.
     * The boundaries mean the nodes that will not be deleted in the range.
     */
    private deleteIndexNodes;
    /**
     * `purge` physically purges the given node from RGATreeSplit.
     */
    purge(node: RGATreeSplitNode<T>): void;
}

/**
 * `RGATreeSplitNode` is a node of RGATreeSplit.
 */
declare class RGATreeSplitNode<T extends RGATreeSplitValue> extends SplayNode<T> implements GCChild {
    private id;
    private removedAt?;
    private prev?;
    private next?;
    private insPrev?;
    private insNext?;
    constructor(id: RGATreeSplitNodeID, value?: T, removedAt?: TimeTicket);
    /**
     * `create` creates a instance of RGATreeSplitNode.
     */
    static create<T extends RGATreeSplitValue>(id: RGATreeSplitNodeID, value?: T): RGATreeSplitNode<T>;
    /**
     * `createComparator` creates a function to compare two RGATreeSplitNodeID.
     */
    static createComparator(): Comparator<RGATreeSplitNodeID>;
    /**
     * `getID` returns the ID of this RGATreeSplitNode.
     */
    getID(): RGATreeSplitNodeID;
    /**
     * `getCreatedAt` returns creation time of the Id of RGATreeSplitNode.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getLength` returns the length of this node.
     */
    getLength(): number;
    /**
     * `getContentLength` returns the length of this value.
     */
    getContentLength(): number;
    /**
     * `getPrev` returns a previous node of this node.
     */
    getPrev(): RGATreeSplitNode<T> | undefined;
    /**
     * `getNext` returns a next node of this node.
     */
    getNext(): RGATreeSplitNode<T> | undefined;
    /**
     * `getInsPrev` returns a previous node of this node insertion.
     */
    getInsPrev(): RGATreeSplitNode<T> | undefined;
    /**
     * `getInsNext` returns a next node of this node insertion.
     */
    getInsNext(): RGATreeSplitNode<T> | undefined;
    /**
     * `getInsPrevID` returns a ID of previous node insertion.
     */
    getInsPrevID(): RGATreeSplitNodeID;
    /**
     * `setPrev` sets previous node of this node.
     */
    setPrev(node?: RGATreeSplitNode<T>): void;
    /**
     * `setNext` sets next node of this node.
     */
    setNext(node?: RGATreeSplitNode<T>): void;
    /**
     * `setInsPrev` sets previous node of this node insertion.
     */
    setInsPrev(node?: RGATreeSplitNode<T>): void;
    /**
     * `setInsNext` sets next node of this node insertion.
     */
    setInsNext(node?: RGATreeSplitNode<T>): void;
    /**
     * `hasNext` checks if next node exists.
     */
    hasNext(): boolean;
    /**
     * `hasInsPrev` checks if previous insertion node exists.
     */
    hasInsPrev(): boolean;
    /**
     * `isRemoved` checks if removed time exists.
     */
    isRemoved(): boolean;
    /**
     * `getRemovedAt` returns the remove time of this node.
     */
    getRemovedAt(): TimeTicket | undefined;
    /**
     * `split` creates a new split node of the given offset.
     */
    split(offset: number): RGATreeSplitNode<T>;
    /**
     * `canDelete` checks if node is able to delete.
     */
    canDelete(editedAt: TimeTicket, maxCreatedAt: TimeTicket): boolean;
    /**
     * `canStyle` checks if node is able to set style.
     */
    canStyle(editedAt: TimeTicket, maxCreatedAt: TimeTicket): boolean;
    /**
     * `remove` removes node of given edited time.
     */
    remove(editedAt?: TimeTicket): void;
    /**
     * `createRange` creates ranges of RGATreeSplitPos.
     */
    createPosRange(): RGATreeSplitPosRange;
    /**
     * `deepcopy` returns a new instance of this RGATreeSplitNode without structural info.
     */
    deepcopy(): RGATreeSplitNode<T>;
    /**
     * `toTestString` returns a String containing
     * the meta data of the node for debugging purpose.
     */
    toTestString(): string;
    private splitValue;
    /**
     * `toIDString` returns a string that can be used as an ID for this position.
     */
    toIDString(): string;
}

/**
 * `RGATreeSplitNodeID` is an ID of RGATreeSplitNode.
 */
declare class RGATreeSplitNodeID {
    private createdAt;
    private offset;
    constructor(createdAt: TimeTicket, offset: number);
    /**
     * `of` creates a instance of RGATreeSplitNodeID.
     */
    static of(createdAt: TimeTicket, offset: number): RGATreeSplitNodeID;
    /**
     * `fromStruct` creates a instance of RGATreeSplitNodeID from the struct.
     */
    static fromStruct(struct: RGATreeSplitNodeIDStruct): RGATreeSplitNodeID;
    /**
     * `getCreatedAt` returns the creation time of this ID.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getOffset` returns returns the offset of this ID.
     */
    getOffset(): number;
    /**
     * `equals` returns whether given ID equals to this ID or not.
     */
    equals(other: RGATreeSplitNodeID): boolean;
    /**
     * `hasSameCreatedAt` returns whether given ID has same creation time with this ID.
     */
    hasSameCreatedAt(other: RGATreeSplitNodeID): boolean;
    /**
     * `split` creates a new ID with an offset from this ID.
     */
    split(offset: number): RGATreeSplitNodeID;
    /**
     * `toStruct` returns the structure of this node id.
     */
    toStruct(): RGATreeSplitNodeIDStruct;
    /**
     * `toTestString` returns a String containing
     * the meta data of the node id for debugging purpose.
     */
    toTestString(): string;
    /**
     * `toIDString` returns a string that can be used as an ID for this node id.
     */
    toIDString(): string;
}

/**
 * `RGATreeSplitNodeIDStruct` is a structure represents the meta data of the node id.
 * It is used to serialize and deserialize the node id.
 */
declare type RGATreeSplitNodeIDStruct = {
    createdAt: TimeTicketStruct;
    offset: number;
};

/**
 * `RGATreeSplitPos` is the position of the text inside the node.
 */
declare class RGATreeSplitPos {
    private id;
    private relativeOffset;
    constructor(id: RGATreeSplitNodeID, relativeOffset: number);
    /**
     * `of` creates a instance of RGATreeSplitPos.
     */
    static of(id: RGATreeSplitNodeID, relativeOffset: number): RGATreeSplitPos;
    /**
     * `fromStruct` creates a instance of RGATreeSplitPos from the struct.
     */
    static fromStruct(struct: RGATreeSplitPosStruct): RGATreeSplitPos;
    /**
     * `getID` returns the ID of this RGATreeSplitPos.
     */
    getID(): RGATreeSplitNodeID;
    /**
     * `getRelativeOffset` returns the relative offset of this RGATreeSplitPos.
     */
    getRelativeOffset(): number;
    /**
     * `getAbsoluteID` returns the absolute id of this RGATreeSplitPos.
     */
    getAbsoluteID(): RGATreeSplitNodeID;
    /**
     *`toTestString` returns a String containing
     * the meta data of the position for debugging purpose.
     */
    toTestString(): string;
    /**
     * `toStruct` returns the structure of this node pos.
     */
    toStruct(): RGATreeSplitPosStruct;
    /**
     * `equals` returns whether given pos equal to this pos or not.
     */
    equals(other: RGATreeSplitPos): boolean;
}

declare type RGATreeSplitPosRange = [RGATreeSplitPos, RGATreeSplitPos];

/**
 * `RGATreeSplitPosStruct` is a structure represents the meta data of the node pos.
 * It is used to serialize and deserialize the node pos.
 */
declare type RGATreeSplitPosStruct = {
    id: RGATreeSplitNodeIDStruct;
    relativeOffset: number;
};

declare interface RGATreeSplitValue {
    length: number;
    substring(indexStart: number, indexEnd?: number): RGATreeSplitValue;
}

/**
 * RHT is replicated hash table by creation time.
 * For more details about RHT: @see http://csl.skku.edu/papers/jpdc11.pdf
 */
declare class RHT {
    private nodeMapByKey;
    private numberOfRemovedElement;
    constructor();
    /**
     * `create` creates a new instance of RHT.
     */
    static create(): RHT;
    /**
     * `getNodeMapByKey` returns the hashtable of RHT.
     */
    getNodeMapByKey(): Map<string, RHTNode>;
    /**
     * `set` sets the value of the given key.
     */
    set(key: string, value: string, executedAt: TimeTicket): [RHTNode | undefined, RHTNode | undefined];
    /**
     * SetInternal sets the value of the given key internally.
     */
    setInternal(key: string, value: string, executedAt: TimeTicket, removed: boolean): void;
    /**
     * `remove` removes the Element of the given key.
     */
    remove(key: string, executedAt: TimeTicket): Array<RHTNode>;
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key: string): boolean;
    /**
     * `get` returns the value of the given key.
     */
    get(key: string): string | undefined;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): RHT;
    /**
     * `toJSON` returns the JSON encoding of this hashtable.
     */
    toJSON(): string;
    /**
     * `size` returns the size of RHT
     */
    size(): number;
    /**
     * `toObject` returns the object of this hashtable.
     */
    toObject(): Record<string, string>;
    [Symbol.iterator](): IterableIterator<RHTNode>;
    /**
     * `purge` purges the given child node.
     */
    purge(child: RHTNode): void;
}

/**
 * `RHTNode` is a node of RHT(Replicated Hashtable).
 */
declare class RHTNode implements GCChild {
    private key;
    private value;
    private updatedAt;
    private _isRemoved;
    constructor(key: string, value: string, updatedAt: TimeTicket, isRemoved: boolean);
    /**
     * `of` creates a new instance of RHTNode.
     */
    static of(key: string, value: string, createdAt: TimeTicket, isRemoved: boolean): RHTNode;
    /**
     * `getKey` returns a key of node.
     */
    getKey(): string;
    /**
     * `getValue` returns a value of node.
     */
    getValue(): string;
    /**
     * `getUpdatedAt` returns updated time of node.
     */
    getUpdatedAt(): TimeTicket;
    /**
     * `isRemoved` returns whether the node has been removed or not.
     */
    isRemoved(): boolean;
    /**
     * `toIDString` returns the IDString of this node.
     */
    toIDString(): string;
    /**
     * `getRemovedAt` returns the time when this node was removed.
     */
    getRemovedAt(): TimeTicket | undefined;
}

/**
 * Definition of all messages the SDK can send to the Devtools panel.
 */
export declare type SDKToPanelMessage = 
/**
* Sent when the dev panel is already opened and listened,
* before the sdk is loaded. If the panel receives this message,
* it will replay its initial "connect" message.
*/
    {
    msg: 'refresh-devtools';
}
/**
* Sent when the document is available for the panel to watch.
*/
| {
    msg: 'doc::available';
    docKey: string;
}
/**
* Sent initially, to synchronize the entire current state of the document.
*/
| {
    msg: 'doc::sync::full';
    docKey: string;
    events: Array<TransactionEvent>;
}
/**
* Sent whenever the document is changed.
*/
| {
    msg: 'doc::sync::partial';
    docKey: string;
    event: TransactionEvent;
};

/**
 * `setLogLevel` sets log level.
 */
export declare function setLogLevel(l: LogLevel): void;

/**
 * `SetOpInfo` represents the information of the set operation.
 */
export declare type SetOpInfo = {
    type: 'set';
    path: string;
    key: string;
};

/**
 * `SnapshotEvent` is an event that occurs when a snapshot is received from
 * the server.
 *
 * @public
 */
export declare interface SnapshotEvent extends BaseDocEvent {
    /**
     * enum {@link DocEventType}.Snapshot
     */
    type: DocEventType.Snapshot;
    source: OpSource.Remote;
    value: {
        snapshot?: string;
        serverSeq: string;
    };
}

/**
 * `SplayNode` is a node of SplayTree.
 */
declare abstract class SplayNode<V> {
    protected value: V;
    private left?;
    private right?;
    private parent?;
    private weight;
    constructor(value: V);
    abstract getLength(): number;
    /**
     * `getNodeString` returns a string of weight and value of this node.
     */
    getNodeString(): string;
    /**
     * `getValue` returns value of this node.
     */
    getValue(): V;
    /**
     * `getLeftWeight` returns left weight of this node.
     */
    getLeftWeight(): number;
    /**
     * `getRightWeight` returns right weight of this node.
     */
    getRightWeight(): number;
    /**
     * `getWeight` returns weight of this node.
     */
    getWeight(): number;
    /**
     * `getLeft` returns a left node.
     */
    getLeft(): SplayNode<V> | undefined;
    /**
     * `getRight` returns a right node.
     */
    getRight(): SplayNode<V> | undefined;
    /**
     * `getParent` returns parent of this node.
     */
    getParent(): SplayNode<V> | undefined;
    /**
     * `hasLeft` check if the left node exists
     */
    hasLeft(): boolean;
    /**
     * `hasRight` check if the right node exists
     */
    hasRight(): boolean;
    /**
     * `hasParent` check if the parent node exists
     */
    hasParent(): boolean;
    /**
     * `setLeft` sets a left node.
     */
    setLeft(left?: SplayNode<V>): void;
    /**
     * `setRight` sets a right node.
     */
    setRight(right?: SplayNode<V>): void;
    /**
     * `setParent` sets a parent node.
     */
    setParent(parent?: SplayNode<V>): void;
    /**
     * `unlink` unlink parent, right and left node.
     */
    unlink(): void;
    /**
     * `hasLinks` checks if parent, right and left node exists.
     */
    hasLinks(): boolean;
    /**
     * `increaseWeight` increases weight.
     */
    increaseWeight(weight: number): void;
    /**
     * `initWeight` sets initial weight of this node.
     */
    initWeight(): void;
}

/**
 * `StatusChangedEvent` is an event that occurs when the status of a document changes.
 *
 * @public
 */
declare interface StatusChangedEvent extends BaseDocEvent {
    /**
     * enum {@link DocEventType}.StatusChanged
     */
    type: DocEventType.StatusChanged;
    source: OpSource;
    value: {
        status: DocumentStatus.Attached;
        actorID: string;
    } | {
        status: DocumentStatus.Detached;
    } | {
        status: DocumentStatus.Removed;
    };
}

/**
 * `StreamConnectionStatus` represents whether the stream connection is connected or not.
 * @public
 */
export declare enum StreamConnectionStatus {
    /**
     * `Connected` means that the stream connection is connected.
     */
    Connected = "connected",
    /**
     * `Disconnected` means that the stream connection is disconnected.
     */
    Disconnected = "disconnected"
}

/**
 * `StyleOpInfo` represents the information of the style operation.
 */
export declare type StyleOpInfo = {
    type: 'style';
    path: string;
    from: number;
    to: number;
    value: {
        attributes: Indexable;
    };
};

declare interface SubscribeFn<T> {
    (next: Observer<T> | NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    (observer: Observer<T>): Unsubscribe;
}

/**
 * `SyncMode` defines synchronization modes for the PushPullChanges API.
 * @public
 */
export declare enum SyncMode {
    /**
     * `Manual` mode indicates that changes are not automatically pushed or pulled.
     */
    Manual = "manual",
    /**
     * `Realtime` mode indicates that changes are automatically pushed and pulled.
     */
    Realtime = "realtime",
    /**
     * `RealtimePushOnly` mode indicates that only local changes are automatically pushed.
     */
    RealtimePushOnly = "realtime-pushonly",
    /**
     * `RealtimeSyncOff` mode indicates that changes are not automatically pushed or pulled,
     * but the watch stream is kept active.
     */
    RealtimeSyncOff = "realtime-syncoff"
}

/**
 * `SyncStatusChangedEvent` is an event that occurs when document is synced with the server.
 *
 * @public
 */
export declare interface SyncStatusChangedEvent extends BaseDocEvent {
    /**
     * enum {@link DocEventType}.SyncStatusChanged
     */
    type: DocEventType.SyncStatusChanged;
    value: DocumentSyncStatus;
}

/**
 * `Text` is an extended data type for the contents of a text editor.
 */
declare class Text_2<A extends Indexable = Indexable> {
    private context?;
    private text?;
    constructor(context?: ChangeContext, text?: CRDTText<A>);
    /* Excluded from this release type: initialize */
    /**
     * `getID` returns the ID of this text.
     */
    getID(): TimeTicket;
    /**
     * `edit` edits this text with the given content.
     */
    edit(fromIdx: number, toIdx: number, content: string, attributes?: A): [number, number] | undefined;
    /**
     * `delete` deletes the text in the given range.
     */
    delete(fromIdx: number, toIdx: number): [number, number] | undefined;
    /**
     * `empty` makes the text empty.
     */
    empty(): [number, number] | undefined;
    /**
     * `setStyle` styles this text with the given attributes.
     */
    setStyle(fromIdx: number, toIdx: number, attributes: A): boolean;
    /**
     * `indexRangeToPosRange` returns TextRangeStruct of the given index range.
     */
    indexRangeToPosRange(range: [number, number]): TextPosStructRange;
    /**
     * `posRangeToIndexRange` returns indexes of the given TextRangeStruct.
     */
    posRangeToIndexRange(range: TextPosStructRange): [number, number];
    /**
     * `toTestString` returns a String containing the meta data of the node
     * for debugging purpose.
     */
    toTestString(): string;
    /**
     * `values` returns values of this text.
     */
    values(): Array<TextValueType<A>>;
    /**
     * `length` returns size of RGATreeList.
     */
    get length(): number;
    /**
     * `checkWeight` returns false when there is an incorrect weight node.
     * for debugging purpose.
     */
    checkWeight(): boolean;
    /**
     * `toString` returns the string representation of this text.
     */
    toString(): string;
    /**
     * `toJSON` returns the JSON string of this tree.
     */
    toJSON(): string;
    /* Excluded from this release type: toJSForTest */
    /**
     * `createRangeForTest` returns pair of RGATreeSplitNodePos of the given indexes
     * for testing purpose.
     */
    createRangeForTest(fromIdx: number, toIdx: number): RGATreeSplitPosRange;
}
export { Text_2 as Text }

/**
 * `TextChange` represents the changes to the text
 * when executing the edit, setstyle methods.
 */
declare interface TextChange<A = Indexable> extends ValueChange<TextValueType<A>> {
    type: TextChangeType;
}

/**
 * `TextChangeType` is the type of TextChange.
 *
 */
declare enum TextChangeType {
    Content = "content",
    Style = "style"
}

/**
 * `TextNode` represents a text node. It has a string value.
 */
export declare type TextNode = {
    type: typeof DefaultTextType;
    value: string;
};

/**
 * @generated from message yorkie.v1.TextNodePos
 */
declare class TextNodePos extends Message<TextNodePos> {
    /**
     * @generated from field: yorkie.v1.TimeTicket created_at = 1;
     */
    createdAt?: TimeTicket_2;

    /**
     * @generated from field: int32 offset = 2;
     */
    offset: number;

    /**
     * @generated from field: int32 relative_offset = 3;
     */
    relativeOffset: number;

    constructor(data?: PartialMessage<TextNodePos>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.TextNodePos";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextNodePos;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextNodePos;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextNodePos;

    static equals(a: TextNodePos | PlainMessage<TextNodePos> | undefined, b: TextNodePos | PlainMessage<TextNodePos> | undefined): boolean;
}

/**
 * `TextOperationInfo` represents the OperationInfo for the yorkie.Text.
 */
export declare type TextOperationInfo = EditOpInfo | StyleOpInfo;

/**
 * `TextPosStruct` represents the structure of RGATreeSplitPos.
 * It is used to serialize and deserialize the RGATreeSplitPos.
 */
export declare type TextPosStruct = {
    id: {
        createdAt: TimeTicketStruct;
        offset: number;
    };
    relativeOffset: number;
};

/**
 * `TextPosStructRange` represents the structure of RGATreeSplitPosRange.
 * It is used to serialize and deserialize the RGATreeSplitPosRange.
 */
export declare type TextPosStructRange = [TextPosStruct, TextPosStruct];

/**
 * `TextValueType` is a value of Text
 * which has a attributes that expresses the text style.
 */
declare interface TextValueType<A> {
    attributes?: A;
    content?: string;
}

/**
 * `TimeTicket` is a timestamp of the logical clock. Ticket is immutable.
 * It is created by `ChangeID`.
 *
 * @public
 */
export declare class TimeTicket {
    private lamport;
    private delimiter;
    private actorID;
    constructor(lamport: default_2, delimiter: number, actorID: string);
    /**
     * `of` creates an instance of Ticket.
     */
    static of(lamport: default_2, delimiter: number, actorID: string): TimeTicket;
    /**
     * `fromStruct` creates an instance of Ticket from the struct.
     */
    static fromStruct(struct: TimeTicketStruct): TimeTicket;
    /**
     * `toIDString` returns the lamport string for this Ticket.
     */
    toIDString(): string;
    /**
     * `toStruct` returns the structure of this Ticket.
     */
    toStruct(): TimeTicketStruct;
    /**
     * `toTestString` returns a string containing the meta data of the ticket
     * for debugging purpose.
     */
    toTestString(): string;
    /**
     * `setActor` creates a new instance of Ticket with the given actorID.
     */
    setActor(actorID: ActorID): TimeTicket;
    /**
     * `getLamportAsString` returns the lamport string.
     */
    getLamportAsString(): string;
    /**
     * `getLamport` returns the lamport.
     */
    getLamport(): default_2;
    /**
     * `getDelimiter` returns delimiter.
     */
    getDelimiter(): number;
    /**
     * `getActorID` returns actorID.
     */
    getActorID(): string;
    /**
     * `after` returns whether the given ticket was created later.
     */
    after(other: TimeTicket): boolean;
    /**
     * `equals` returns whether the given ticket was created.
     */
    equals(other: TimeTicket): boolean;
    /**
     * `compare` returns an integer comparing two Ticket.
     *  The result will be 0 if id==other, -1 if `id < other`, and +1 if `id > other`.
     *  If the receiver or argument is nil, it would panic at runtime.
     */
    compare(other: TimeTicket): number;
}

/**
 * @generated from message yorkie.v1.TimeTicket
 */
declare class TimeTicket_2 extends Message<TimeTicket_2> {
    /**
     * @generated from field: int64 lamport = 1 [jstype = JS_STRING];
     */
    lamport: string;

    /**
     * @generated from field: uint32 delimiter = 2;
     */
    delimiter: number;

    /**
     * @generated from field: bytes actor_id = 3;
     */
    actorId: Uint8Array;

    constructor(data?: PartialMessage<TimeTicket_2>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.TimeTicket";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeTicket_2;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeTicket_2;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeTicket_2;

    static equals(a: TimeTicket_2 | PlainMessage<TimeTicket_2> | undefined, b: TimeTicket_2 | PlainMessage<TimeTicket_2> | undefined): boolean;
}

/**
 * `TimeTicketStruct` is a structure represents the meta data of the ticket.
 * It is used to serialize and deserialize the ticket.
 */
export declare type TimeTicketStruct = {
    lamport: string;
    delimiter: number;
    actorID: ActorID;
};

/**
 * `toChangeID` converts the given model to Protobuf format.
 */
declare function toChangeID(changeID: ChangeID): ChangeID_2;

/**
 * `toChangePack` converts the given model to Protobuf format.
 */
declare function toChangePack(pack: ChangePack<Indexable>): ChangePack_2;

/**
 * `toHexString` converts the given byte array to hex string.
 */
declare function toHexString(bytes: Uint8Array): string;

/**
 * `TokenType` represents the type of token in XML representation.
 */
declare enum TokenType {
    /**
     * `Start` represents that the start token type.
     */
    Start = "Start",
    /**
     * `End` represents that the end token type.
     */
    End = "End",
    /**
     * `Text` represents that the text token type.
     */
    Text = "Text"
}

/**
 * `toOperation` converts the given model to Protobuf format.
 */
declare function toOperation(operation: Operation): Operation_2;

/**
 * `toUnit8Array` converts the given hex string to byte array.
 */
declare function toUint8Array(hex: string): Uint8Array;

/**
 * `TransactionEvent` represents document events that occur within
 * a single transaction (e.g., doc.update).
 */
export declare type TransactionEvent<P extends Indexable = Indexable> = Array<DocEvent<P>>;

/**
 * `Tree` is a CRDT-based tree structure that is used to represent the document
 * tree of text-based editor such as ProseMirror.
 */
export declare class Tree {
    private initialRoot?;
    private context?;
    private tree?;
    constructor(initialRoot?: ElementNode);
    /* Excluded from this release type: initialize */
    /**
     * `getID` returns the ID of this tree.
     */
    getID(): TimeTicket;
    /**
     * `buildRoot` builds the root of this tree with the given initial root
     * which set by the user.
     */
    buildRoot(context: ChangeContext): CRDTTreeNode;
    /**
     * `getSize` returns the size of this tree.
     */
    getSize(): number;
    /**
     * `getNodeSize` returns the node size of this tree.
     */
    getNodeSize(): number;
    /**
     * `getIndexTree` returns the index tree of this tree.
     */
    getIndexTree(): IndexTree<CRDTTreeNode>;
    /**
     * `styleByPath` sets the attributes to the elements of the given path.
     */
    styleByPath(path: Array<number>, attributes: {
        [key: string]: any;
    }): void;
    /**
     * `style` sets the attributes to the elements of the given range.
     */
    style(fromIdx: number, toIdx: number, attributes: {
        [key: string]: any;
    }): void;
    /**
     * `removeStyle` removes the attributes to the elements of the given range.
     */
    removeStyle(fromIdx: number, toIdx: number, attributesToRemove: Array<string>): void;
    private editInternal;
    /**
     * `editByPath` edits this tree with the given node and path.
     */
    editByPath(fromPath: Array<number>, toPath: Array<number>, content?: TreeNode, splitLevel?: number): boolean;
    /**
     * `editBulkByPath` edits this tree with the given node and path.
     */
    editBulkByPath(fromPath: Array<number>, toPath: Array<number>, contents: Array<TreeNode>, splitLevel?: number): boolean;
    /**
     * `edit` edits this tree with the given nodes.
     */
    edit(fromIdx: number, toIdx: number, content?: TreeNode, splitLevel?: number): boolean;
    /**
     * `editBulk` edits this tree with the given nodes.
     */
    editBulk(fromIdx: number, toIdx: number, contents: Array<TreeNode>, splitLevel?: number): boolean;
    /**
     * `toXML` returns the XML string of this tree.
     */
    toXML(): string;
    /**
     * `toJSON` returns the JSON string of this tree.
     */
    toJSON(): string;
    /* Excluded from this release type: toJSForTest */
    /* Excluded from this release type: toJSInfoForTest */
    /**
     * `getRootTreeNode` returns TreeNode of this tree.
     */
    getRootTreeNode(): TreeNode;
    /**
     * `indexToPath` returns the path of the given index.
     */
    indexToPath(index: number): Array<number>;
    /**
     * `pathToIndex` returns the index of given path.
     */
    pathToIndex(path: Array<number>): number;
    /**
     * `pathRangeToPosRange` converts the path range into the position range.
     */
    pathRangeToPosRange(range: [Array<number>, Array<number>]): TreePosStructRange;
    /**
     * `indexRangeToPosRange` converts the index range into the position range.
     */
    indexRangeToPosRange(range: [number, number]): TreePosStructRange;
    /**
     * `posRangeToIndexRange` converts the position range into the index range.
     */
    posRangeToIndexRange(range: TreePosStructRange): [number, number];
    /**
     * `posRangeToPathRange` converts the position range into the path range.
     */
    posRangeToPathRange(range: TreePosStructRange): [Array<number>, Array<number>];
}

/**
 * `TreeChange` represents the change in the tree.
 */
export declare type TreeChange = {
    actor: ActorID;
    type: TreeChangeType.Content;
    from: number;
    to: number;
    fromPath: Array<number>;
    toPath: Array<number>;
    value?: Array<TreeNode>;
    splitLevel?: number;
} | {
    actor: ActorID;
    type: TreeChangeType.Style;
    from: number;
    to: number;
    fromPath: Array<number>;
    toPath: Array<number>;
    value: {
        [key: string]: string;
    };
    splitLevel?: number;
} | {
    actor: ActorID;
    type: TreeChangeType.RemoveStyle;
    from: number;
    to: number;
    fromPath: Array<number>;
    toPath: Array<number>;
    value?: Array<string>;
    splitLevel?: number;
};

/**
 * `TreeChangeType` represents the type of change in the tree.
 */
export declare enum TreeChangeType {
    Content = "content",
    Style = "style",
    RemoveStyle = "removeStyle"
}

/**
 * `TreeEditOpInfo` represents the information of the tree edit operation.
 */
export declare type TreeEditOpInfo = {
    type: 'tree-edit';
    path: string;
    from: number;
    to: number;
    value?: Array<TreeNode>;
    splitLevel?: number;
    fromPath: Array<number>;
    toPath: Array<number>;
};

/**
 * `TreeNode` represents a node in the tree.
 */
export declare type TreeNode = TextNode | ElementNode;

/**
 * @generated from message yorkie.v1.TreeNode
 */
declare class TreeNode_2 extends Message<TreeNode_2> {
    /**
     * @generated from field: yorkie.v1.TreeNodeID id = 1;
     */
    id?: TreeNodeID;

    /**
     * @generated from field: string type = 2;
     */
    type: string;

    /**
     * @generated from field: string value = 3;
     */
    value: string;

    /**
     * @generated from field: yorkie.v1.TimeTicket removed_at = 4;
     */
    removedAt?: TimeTicket_2;

    /**
     * @generated from field: yorkie.v1.TreeNodeID ins_prev_id = 5;
     */
    insPrevId?: TreeNodeID;

    /**
     * @generated from field: yorkie.v1.TreeNodeID ins_next_id = 6;
     */
    insNextId?: TreeNodeID;

    /**
     * @generated from field: int32 depth = 7;
     */
    depth: number;

    /**
     * @generated from field: map<string, yorkie.v1.NodeAttr> attributes = 8;
     */
    attributes: { [key: string]: NodeAttr };

    constructor(data?: PartialMessage<TreeNode_2>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.TreeNode";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TreeNode_2;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TreeNode_2;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TreeNode_2;

    static equals(a: TreeNode_2 | PlainMessage<TreeNode_2> | undefined, b: TreeNode_2 | PlainMessage<TreeNode_2> | undefined): boolean;
}

/**
 * `TreeNodeForTest` represents the JSON representation of a node in the tree.
 * It is used for testing.
 */
declare type TreeNodeForTest = TreeNode & {
    children?: Array<TreeNodeForTest>;
    size: number;
    isRemoved: boolean;
};

/**
 * @generated from message yorkie.v1.TreeNodeID
 */
declare class TreeNodeID extends Message<TreeNodeID> {
    /**
     * @generated from field: yorkie.v1.TimeTicket created_at = 1;
     */
    createdAt?: TimeTicket_2;

    /**
     * @generated from field: int32 offset = 2;
     */
    offset: number;

    constructor(data?: PartialMessage<TreeNodeID>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.TreeNodeID";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TreeNodeID;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TreeNodeID;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TreeNodeID;

    static equals(a: TreeNodeID | PlainMessage<TreeNodeID> | undefined, b: TreeNodeID | PlainMessage<TreeNodeID> | undefined): boolean;
}

/**
 * `TreeNodeInfo` represents the crdt tree node information in devtools.
 */
declare type TreeNodeInfo = {
    id: string;
    type: string;
    parent?: string;
    size: number;
    value?: string;
    removedAt?: string;
    isRemoved: boolean;
    insPrev?: string;
    insNext?: string;
    children: Array<TreeNodeInfo>;
    attributes?: object;
    depth: number;
    index?: number;
    path?: Array<number>;
    pos?: CRDTTreePosStruct;
};

/**
 * `TreeNodePair` represents a pair of CRDTTreeNode. It represents the position
 * of the node in the tree with the left and parent nodes.
 */
declare type TreeNodePair = [CRDTTreeNode, CRDTTreeNode];

/**
 * @generated from message yorkie.v1.TreeNodes
 */
declare class TreeNodes extends Message<TreeNodes> {
    /**
     * @generated from field: repeated yorkie.v1.TreeNode content = 1;
     */
    content: TreeNode_2[];

    constructor(data?: PartialMessage<TreeNodes>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.TreeNodes";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TreeNodes;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TreeNodes;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TreeNodes;

    static equals(a: TreeNodes | PlainMessage<TreeNodes> | undefined, b: TreeNodes | PlainMessage<TreeNodes> | undefined): boolean;
}

/**
 * `NoteType` is the type of a node in the tree.
 */
declare type TreeNodeType = string;

/**
 * `TreeOperationInfo` represents the OperationInfo for the yorkie.Tree.
 */
export declare type TreeOperationInfo = TreeEditOpInfo | TreeStyleOpInfo;

/**
 * `TreePos` is the position of a node in the tree.
 *
 * `offset` is the position of node's token. For example, if the node is an
 * element node, the offset is the index of the child node. If the node is a
 * text node, the offset is the index of the character.
 */
declare type TreePos<T extends IndexTreeNode<T>> = {
    node: T;
    offset: number;
};

/**
 * @generated from message yorkie.v1.TreePos
 */
declare class TreePos_2 extends Message<TreePos_2> {
    /**
     * @generated from field: yorkie.v1.TreeNodeID parent_id = 1;
     */
    parentId?: TreeNodeID;

    /**
     * @generated from field: yorkie.v1.TreeNodeID left_sibling_id = 2;
     */
    leftSiblingId?: TreeNodeID;

    constructor(data?: PartialMessage<TreePos_2>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.TreePos";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TreePos_2;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TreePos_2;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TreePos_2;

    static equals(a: TreePos_2 | PlainMessage<TreePos_2> | undefined, b: TreePos_2 | PlainMessage<TreePos_2> | undefined): boolean;
}

/**
 * `TreePosRange` represents a pair of CRDTTreePos.
 */
declare type TreePosRange = [CRDTTreePos, CRDTTreePos];

/**
 * `TreePosStructRange` represents the structure of TreeRange.
 * It is used to serialize and deserialize the TreeRange.
 */
export declare type TreePosStructRange = [CRDTTreePosStruct, CRDTTreePosStruct];

/**
 * `TreeStyleOpInfo` represents the information of the tree style operation.
 */
export declare type TreeStyleOpInfo = {
    type: 'tree-style';
    path: string;
    from: number;
    to: number;
    fromPath: Array<number>;
    toPath: Array<number>;
    value: {
        attributes?: Indexable;
        attributesToRemove?: Array<string>;
    };
};

/**
 * `TreeToken` represents the token of the tree in XML representation.
 */
declare type TreeToken<T> = [T, TokenType];

export declare type Unsubscribe = () => void;

export declare interface UnwatchedEvent<P extends Indexable> extends BaseDocEvent {
    type: DocEventType.Unwatched;
    source: OpSource.Remote;
    value: {
        clientID: ActorID;
        presence: P;
    };
}

declare interface ValueChange<T> {
    actor: ActorID;
    from: number;
    to: number;
    value?: T;
}

/**
 * @generated from enum yorkie.v1.ValueType
 */
declare enum ValueType {
    /**
     * @generated from enum value: VALUE_TYPE_NULL = 0;
     */
    NULL = 0,

    /**
     * @generated from enum value: VALUE_TYPE_BOOLEAN = 1;
     */
    BOOLEAN = 1,

    /**
     * @generated from enum value: VALUE_TYPE_INTEGER = 2;
     */
    INTEGER = 2,

    /**
     * @generated from enum value: VALUE_TYPE_LONG = 3;
     */
    LONG = 3,

    /**
     * @generated from enum value: VALUE_TYPE_DOUBLE = 4;
     */
    DOUBLE = 4,

    /**
     * @generated from enum value: VALUE_TYPE_STRING = 5;
     */
    STRING = 5,

    /**
     * @generated from enum value: VALUE_TYPE_BYTES = 6;
     */
    BYTES = 6,

    /**
     * @generated from enum value: VALUE_TYPE_DATE = 7;
     */
    DATE = 7,

    /**
     * @generated from enum value: VALUE_TYPE_JSON_OBJECT = 8;
     */
    JSON_OBJECT = 8,

    /**
     * @generated from enum value: VALUE_TYPE_JSON_ARRAY = 9;
     */
    JSON_ARRAY = 9,

    /**
     * @generated from enum value: VALUE_TYPE_TEXT = 10;
     */
    TEXT = 10,

    /**
     * @generated from enum value: VALUE_TYPE_INTEGER_CNT = 11;
     */
    INTEGER_CNT = 11,

    /**
     * @generated from enum value: VALUE_TYPE_LONG_CNT = 12;
     */
    LONG_CNT = 12,

    /**
     * @generated from enum value: VALUE_TYPE_TREE = 13;
     */
    TREE = 13,
}

/**
 * @generated from message yorkie.v1.WatchDocumentResponse
 */
declare class WatchDocumentResponse extends Message<WatchDocumentResponse> {
    /**
     * @generated from oneof yorkie.v1.WatchDocumentResponse.body
     */
    body: {
        /**
         * @generated from field: yorkie.v1.WatchDocumentResponse.Initialization initialization = 1;
         */
        value: WatchDocumentResponse_Initialization;
        case: "initialization";
    } | {
        /**
         * @generated from field: yorkie.v1.DocEvent event = 2;
         */
        value: DocEvent_2;
        case: "event";
    } | { case: undefined; value?: undefined };

    constructor(data?: PartialMessage<WatchDocumentResponse>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.WatchDocumentResponse";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WatchDocumentResponse;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WatchDocumentResponse;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WatchDocumentResponse;

    static equals(a: WatchDocumentResponse | PlainMessage<WatchDocumentResponse> | undefined, b: WatchDocumentResponse | PlainMessage<WatchDocumentResponse> | undefined): boolean;
}

/**
 * @generated from message yorkie.v1.WatchDocumentResponse.Initialization
 */
declare class WatchDocumentResponse_Initialization extends Message<WatchDocumentResponse_Initialization> {
    /**
     * @generated from field: repeated string client_ids = 1;
     */
    clientIds: string[];

    constructor(data?: PartialMessage<WatchDocumentResponse_Initialization>);

    static readonly runtime: typeof proto3;
    static readonly typeName = "yorkie.v1.WatchDocumentResponse.Initialization";
    static readonly fields: FieldList;

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WatchDocumentResponse_Initialization;

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WatchDocumentResponse_Initialization;

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WatchDocumentResponse_Initialization;

    static equals(a: WatchDocumentResponse_Initialization | PlainMessage<WatchDocumentResponse_Initialization> | undefined, b: WatchDocumentResponse_Initialization | PlainMessage<WatchDocumentResponse_Initialization> | undefined): boolean;
}

export declare interface WatchedEvent<P extends Indexable> extends BaseDocEvent {
    type: DocEventType.Watched;
    source: OpSource.Remote;
    value: {
        clientID: ActorID;
        presence: P;
    };
}

/**
 * `WrappedElement` is a wrapper of JSONElement that provides `getID()`.
 */
export declare type WrappedElement<T = unknown, A extends Indexable = Indexable> = Primitive | JSONObject<T> | JSONArray<T> | Text_2<A> | Counter | Tree;

export { }


declare global {
    interface Window {
        transactionEventsByDocKey: Map<string, Array<TransactionEvent>>;
    }
}

